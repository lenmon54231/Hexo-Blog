---
title: 关于AI的一些使用
date: 2025-07-08 15:01:00
tags: [AI]
---


## 使用AI编辑器也应该有技巧

AI编辑器可以直接根据用户输入的自然语言进行代码生成。

那么，如何**组织好提示词**或者**使用一些技巧来帮助AI更准确的理解并生成代码**就变得十分重要！

同时，Cursor作为一个工具，必然有一些**配置或者使用技巧**，我们会跟随Cursor新版本的发布，一起同步更新。

这里记录一下对AI工具的一些使用技巧，目前主要使用**cursor**。

<!-- more -->

### 以下内容主要针对Cursor的使用

### 配置rules（给AI指定一个代码规范）

在项目根目录下新建文件夹/.cursor/rules，里面添加如下文件

[css.mdc](https://limengtupian.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2BLOG%E4%B8%93%E7%94%A8%E5%9B%BE%E5%BA%93/ai/css.mdc)

[general.mdc](https://limengtupian.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2BLOG%E4%B8%93%E7%94%A8%E5%9B%BE%E5%BA%93/ai/general.mdc)

[react.mdc](https://limengtupian.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2BLOG%E4%B8%93%E7%94%A8%E5%9B%BE%E5%BA%93/ai/react.mdc)

[tailwind.mdc](https://limengtupian.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2BLOG%E4%B8%93%E7%94%A8%E5%9B%BE%E5%BA%93/ai/tailwind.mdc)

[css.mdc](https://limengtupian.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2BLOG%E4%B8%93%E7%94%A8%E5%9B%BE%E5%BA%93/ai/css.mdc)

[vue.mdc](https://limengtupian.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2BLOG%E4%B8%93%E7%94%A8%E5%9B%BE%E5%BA%93/ai/vue.mdc)

> 当我们配置了rules 后，cursor生成的代码则会按照mdc的规则来生成代码。

> 当然实际上测试过程中也会发生不按照规则生成的情况，这种情况可以让他重新根据规则修改。

我们可以在cursor设置》rules中看到规则配置

![rules](https://limengtupian.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2BLOG%E4%B8%93%E7%94%A8%E5%9B%BE%E5%BA%93/ai/rules.png)

### Cursor的几大模式分别代表着什么？

![模式](https://limengtupian.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2BLOG%E4%B8%93%E7%94%A8%E5%9B%BE%E5%BA%93/ai/%E6%A8%A1%E5%BC%8F.png)

#### Ask模式：不只是问答(主要用于搜索方案)

* 允许Cursor理解和索引你的整个代码库

* 允许Cursor连接互联网，检索最新的技术信息、文档和解决方案

* 在项目中快速定位特定代码模式，比系统自带的搜索功能更智能

```txt
// 使用Grep功能
在项目中找出所有未处理Promise错误的代码段
```

* 允许Cursor在对话中直接引用和分析项目中的特定文件，无需你手动复制内容。

#### Manual模式：精准控制（主要用于局部代码修改）

* 聚焦于代码修改

* 批量修改、重构和Reapply（重新应用之前的修改）。

* 允许你在Manual模式下直接删除文件，这在重构和清理项目时特别有用。

#### Agent模式：全能开发（整个项目都可以使用Agent模式开发）

* Agent模式集成了所有搜索功能（Codebase、Web、Grep、Read File），并能够在任务过程中自主决定何时使用哪种搜索方式

* Agent模式拥有完整的代码编辑能力，可以创建、修改、重构和删除代码，同时保持代码质量和一致性。

* Run能力是Agent模式独有的，它允许Cursor执行代码、运行测试、启动服务，并根据结果调整实现。

#### 不同模式组合使用

1. 使用Ask模式+Web功能探索最佳实现方法

2. 使用Agent模式规划和执行主要开发工作

3. 使用Manual模式+Rules功能进行精细调整

4. 使用Agent模式+Run功能进行测试和修复

### 使用AI编辑器的几个建议

#### 1. 尽量不要自己修改代码，而是让AI去修改

经过测试可以发现，AI是不会每时每刻都关注代码有了哪些变化。

也就是说有时候，你自己修改了一些代码，比如：将延迟settimeout从500改成了1000，后面AI修改新的需求时又涉及到这部分代码，AI很有可能会将1000的延迟改回500，因为AI还停留在之前的延迟500的需求之上。

#### 2. 将commit的频率增加，方便回退代码

AI有时候会进行大量的代码修改并且产生新的bug，此时你觉得已经无法继续往下生成代码了，想让AI返回到某个版本或者某个功能时。

AI并不会真的像reset那样返回到某个版本，而是类似重新思考一阵后，再将新思考的代码替换上去。

也就是说，AI并没有严格的类似git的版本逻辑，而是更像一个人类的操作，凭借自己的记忆或者经验来恢复某些代码。


#### 3. 。。。

### AI有时候会头脑混乱，如何去引导AI？

#### 当你让AI生成某些特定功能时，AI会反复的生成一些之前的错误代码。此时，你的提示词已经无法再引导AI往正确的方向进行操作。

那么，你可以尝试这么操作：

1. 让AI新生成一个空白页面；
2. 给AI提示词，让他把最核心的功能添加进去（保持最少、最小的代码），让其运行成功，并完成你的需求后；
3. 让AI参考新页面的代码，将正确代码同步到之前的页面中去；

实际上，不止AI这么操作，如果是我们人类遇到了复杂的需求，无法在复杂的代码中直接找出问题来，我们有时候也采用的这种方式：

> 1. 新起一个页面只保留基础功能，其他无关功能都去掉；
> 2. 然后在基础页面上添加需要的功能，并且进行debug。


#### AI会根据你的反馈，逐步生成正确代码，但之前的错误代码AI也会记录，这些之前的错误代码有时候也会导致AI思路混乱

如果你发现AI的后续思路是正确的，但是之前生成的代码是明显有缺陷的。

这种情况下，之前的代码反而会扰乱AI当前的思路。

此时，你可以尝试这么做：

1. 告诉AI：我准备将代码还原到某个版本了，你可以**先记录一下正确的代码生成步骤**，后续我们要重新生成这块的代码；
2. 然后将本地代码还原到上一个commit版本；
3. 告诉AI版本已经回退了，**让AI重新按照步骤1、2、3、4去生成代码**，此时，AI的思路就不会受到之前错误代码的干扰，

> 由此我们可以得到一个结论：**在AI编程的过程中，频繁的将正确代码进行commit是一件非常有必要的事情**，可以方便我们随时回退到上一个正确版本

#### 经常创建新的对话

当你新的功能跟之前的代码没有任何关系时，最好新开对话，避免之前的上下文对后面的功能开发造成污染。

当然，现在Cursor也提供了记忆模式，可以通过用户手动输入："记住......" 类似这种关键词来保留之前的一些逻辑，同时，Cursor自身也会自动的记忆某些重要代码。

所以，我们生成代码时，更倾向于小范围变动代码，而不是输入一个很大很宽泛的需求。

### 有现成代码给AI作参考会是很高效的一种方式

当你能够找到一份已经实现了功能的代码，你只是需要将其移植过来，并进行一些修改时。

这种情况下，将两个项目都放入同一个工作区（同一个文件夹下），用AI编辑器打开，AI编辑器就能够读取两个项目的文件。

你可以让**AI读取某些已完成的功能并进行移植**。

根据实际的测试，发现AI极其擅长干这种事情，比如： 

1. 已经用vue3+tresjs实现了一个自发光的平面mesh，让AI将其改造成 react 组件；
2. 分析之前的模型效果，将其效果应用到新的项目模型中来；


### 自己debug修复问题后，如何继续跟AI沟通？

有时候，AI排查问题是很精准的，但是大多数时间AI遇到复杂问题时的debug能力都不够，此时，还是要依靠人工排查bug。

当你排查出了bug之后，推荐跟AI进行沟通，否则可能会出现AI在后续的迭代中偷偷将代码还原的问题。

沟通内容可以是：我通过XXX实现了YYY功能，为什么XXX可以实现功能？

这样，后续AI也可以同步当前你修改的这部分代码。

### Cursor已经提供了MCP的使用配置项，未来MCP会如何发展？

之前尝试**Cursor + MCP + Blender**，设想可以改变项目中建模和模型设计的工作流。

实际上，现阶段的Blender所提供的api功能，无法支撑复杂的建模需求，特别是修改模型形状的需求。

但是，MCP的发展不是一蹴而就的，一开始必然是一些简单、机械、重复的工作被MCP替代。

在可以预见的未来，我们的工作模式很可能会通过多个Service来完成，

比如操作Figma，那么就使用Figma Service，生成设计图；

操作高德地图，那么就使用Tmap Service，生成地图；

操作Git，那么就使用Git Service，进行版本管理；

操作CI/CD，那么就使用CI/CD Service，进行服务更新部署；



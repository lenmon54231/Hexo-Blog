---
title: 微信小程序使用
date: 2022-09-15 11:27:37
tags: [微信小程序]
---

## 微信小程序使用

<!-- more -->

### 微信小程序内嵌 H5

#### 客户方操作

1. 登录：https://mp.weixin.qq.com/
2. 左侧菜单栏：开发管理>> 开发设置
3. 找到业务域名，点击开始配置
4. 下载校验文件
5. 等待第三方上传校验文件
6. 继续校验文件验证流程

#### 第三方操作

1. 将客户提供的校验文件上传到服务器根目录
2. 通知客户已经上传校验文件，并让客户验证

### 微信 ab 转 base64

```js
import { filetypemime } from "magic-bytes.js";

export function generateDataUrl(ab, mime) {
  if (!mime) {
    const mimeList = filetypemime(new Uint8Array(ab, 0, 100));
    if (mimeList?.length) {
      mime = mimeList[0];
    } else {
      throw new TypeError("无法检测出文件MIME类型");
    }
  } else if (!mime.includes("/")) {
    throw new TypeError("请输入正确的MIME格式");
  }

  return `data:${mime};base64,${wx.arrayBufferToBase64(ab)}`;
}

generateDataUrl(ab);
```

### 小程序本身封装的组件

1. picker（从底部弹起的滚动选择器）

   ```js
   <picker
     bindchange="bindPickerChange"
     value="{{selectList[index].name}}"
     range="{{selectList}}"
     range-key="{{'name'}}"
   >
     <view class="picker">{{ currentType }}</view>
   </picker>
   ```

   外层用 picker 包裹，内部通过 range 设定滚动数据，range-key 做渲染关键词，最后获得的是 value 的值。

   bindPickerChange 方法做赋值的操作（略。。。）

2. scroll-view（可滚动视图区域)

   ```js
   <scroll-view scroll-x="true" class="nav" scroll-left="{{navScrollLeft}}" scroll-with-animation="{{true}}">
   			<block wx:for="{{classifyList}}" wx:for-index="idx" wx:for-item="item" wx:key="idx">
   				<view class="nav-item {{currentTab == idx ?'active':''}} flex_center_center" data-current="{{idx}}" data-id='{{item.classify_id}}' data-int='{{idx}}' data-name="{{item.name}}" bindtap="switchNav">
   					<text class="t_name">{{item.name}}</text>
   				</view>
   			</block>
   </scroll-view>
   ```

   scroll-left:设置横向滚动条位置

   scroll-with-animation:在设置滚动条位置时使用动画过渡

3. swiper (滑块视图容器)

   ```js
   <swiper
     class="swipers"
     autoplay="{{false}}"
     duration="0"
     current="{{currentTab}}"
     bindchange="swiperChange"
   >
     <block
       wx:for="{{classifyList}}"
       wx:for-index="idxs"
       data-index="{{idxs}}"
       wx:for-item="item"
       wx:key="idx"
     >
       <swiper-item catchtouchmove="stopTouchMove"></swiper-item>
     </block>
   </swiper>
   ```

   autoplay:是否自动切换(轮播图的形式)

   duration:滑动动画时长

   current：当前所在滑块的 index

   catchtouchmove：禁止用户手动滑动页面

4. cover-view（覆盖在原生组件之上的文本视图）cover-image（覆盖在原生组件之上的图片视图）

   ```js
   <cover-view hidden="{{!hidePause}}" catchtap="pauseVideo" class="pause-video"></cover-view>
   <cover-image hidden="{{hidePause}}" catchtap="replayVideo" src="/assets/pause@2x.png" class="play-video"></cover-image>
   <cover-view style="padding-top:{{navTop}}px;height:{{navHeight}}px" class="nav">
   	<cover-image catchtap="gotoPrev" src="/assets/ic_cancel_white@2x.png" class="back-icon"></cover-image>
   </cover-view>
   ```

### 手动封装的组件

1. AlertBox(页面中间出现的弹框，中间为文字提示，拥有取消和确定按钮)

   ```js
   //父页面中使用
   <AlertBox
     bind:getUserConfirmResult="getUserConfirmResult"
     alert_title="{{alert_title}}"
     is_show="{{is_show}}"
   ></AlertBox>
   ```

   ```js
   //子页面的结构
    <!--弹框-->
     <view wx:if="{{is_show}}" class="alert_box">
       <view class="clearfloat">
         <view bindtap="closeButton" class="alert_close">
           <image src="../../assets/close@2x.png" mode="widthFix"></image>
         </view>
       </view>

       <view class="alert_title">{{alert_title}}</view>
       <view class="alert_button">
         <button class="confirm_button" bindtap="confirmButton">确定</button>
       </view>
     </view>
   ```

   涉及到父子组件传值的说明：

   父组件中：bind:getUserConfirmResult = "getUserConfirmResult"相当于自定义事件。可以从子组件获取到用户对于取消和确定的值，从而选择不同的显示效果。

   ```js
   //父组件调用自定义方法
   getUserConfirmResult(e) {
       //console.info("e", e)
       let that = this;
       that.setData({
         is_show: false
       });
     },
   ```

   ```js
   //子组件中调用的方法。通过this.triggerEvent()通知到父组件的自定义事件。类似于 vue 中 this.$emit。
   confirmButton:function(){
         console.info("1111111")
         let that = this;

         let myEventDetail = {
           is_show:false,
         };
         let myEventOption = {bubbles:false};
         that.triggerEvent('getUserConfirmResult', myEventDetail, myEventOption)
       },
   ```

   自定义组件触发事件时，需要使用 `triggerEvent` 方法，指定事件名、detail 对象和事件选项：

   选项：bubbles ： 事件是否冒泡；composed：事件是否可以穿越组件边界；capturePhase： 事件是否拥有捕获阶段

### 使用彩色的图标 1

```js
配合阿里iconfont，下载icon项目，进入iconfont文件夹
npm install -g iconfont-tools
iconfont-tools
在原来下载的目录中多出来一个文件夹
打开文件夹选择其中的wxss文件引入到微信小程序中即可
```

使用如下：

```js
<icon class="t-icon t-icon-ziyuan9"></icon>;
icon - ziyuan9就是iconfont中复制的class;
```

### 使用彩色的图标 2

阿里 iconfont 提供了 Symbol 类型的引入方式，拥有很多优点，记录下再小程序中的使用

```js
npm install mini-program-iconfont-cli --save-dev

npx iconfont-init
# 可传入配置输出路径
# npx iconfont-init --output iconfont.json
```

初始化后会生成一个 json 配置文件,修改配置如下

```js
{
  "symbol_url": "//at.alicdn.com/t/font_2428200_oocwz3ghukn.js",
  "save_dir": "miniprogram/components/iconfont",
  "use_rpx": true,
  "trim_icon_prefix": "icon",
  "default_icon_size": 50
}
```

symbol_url：将官网的地址引入

save_dir：根据自己的目录生成

生成标准组件

```js
# 可传入配置文件路径
# npx iconfont-XXXX --config iconfont.json

# 微信小程序
npx iconfont-wechat

# 支付宝小程序
npx iconfont-alipay

# 百度小程序
npx iconfont-baidu

# 头条小程序
npx iconfont-toutiao

# QQ小程序
npx iconfont-qq
```

引入

在根目录 的 app.json 文件中引入全局图标组件，避免每个 page 都引入，也可单个 page 引入

```
// 绝对路径
{
    "usingComponents": {
      "iconfont": "components/iconfont/iconfont"
    }
}
```

使用组件

```js
// 原色彩
<iconfont name="alipay" />

// 单色：红色
<iconfont name="alipay" color="red" />

// 多色：红色+橘色
<iconfont name="alipay" color="{{['red', 'orange']}}" size="300" />

// 不同格式的颜色写法
<iconfont name="alipay" color="{{['#333', 'rgb(50, 124, 39)']}}" />
```

### 微信浏览器打开 h5，然后跳转小程序

```vue
<template>
  <div class="mp-btn-mask">
    <wx-open-launch-weapp
      id="launch-btn"
      ref="btnBox"
      class="launch-mp-btn"
      :appid="mpConfig.appid"
      :path="mpConfig.path"
      @ready="ready"
      @launch="launch"
      @error="error"
      style="display: block"
    >
      <script type="text/wxtag-template">
        <style>
          .btn {
            display: block;
            width: 220px;
            height: 45px;
            line-height: 45px;
            text-align: center;
            background: #51afaf;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 400;
            color: #fff;
            letter-spacing: 3px;
            padding: 0;
          }
        </style>
        <div class="btn">前往展示</div>
      </script>
    </wx-open-launch-weapp>
    <!-- <div class="mask-btn" >{{ text }}</div> -->
  </div>
</template>

<script>
import Vue from "vue";
// 忽略自定义元素标签抛出的报错
Vue.config.ignoredElements = ["wx-open-launch-weapp"];
export default {
  name: "BuyBtn",
  props: {
    mpConfig: {
      type: Object,
      default: function () {
        return {
          appid: "wxc9a643121000b22b",
          path: "pages/product-list/product-list.html?categoryId=46",
        };
      },
    },
  },
  data() {
    return {
      text: "...",
    };
  },
  methods: {
    ready(e) {
      console.log("ready", e);
      this.text = "前往展示";
      document.getElementById("launch-btn").click();
      console.log("click after", document.getElementById("launch-btn"));
      // console.log(
      //   'document.getElementById("innerBtn")',
      //   document.getElementById("launch-btn").children
      // );
    },
    launch(e) {
      console.log("launch", e);
    },
    error(e) {
      console.log("error", e);
    },
  },
};
</script>

<style lang="scss" scoped>
// .mp-btn-mask {
//   // width:60vw;
//   height: 12vw;
//   position: relative;
//   overflow: hidden;
//   .mask-btn {
//     position: absolute;
//     left: 0;
//     top: 0;
//     width: 60vw;
//     height: 12vw;
//     background: #51afaf;
//     border-radius: 2.13vw;
//     font-size: 4vw;
//     font-weight: 400;
//     color: #ffffff;
//     letter-spacing: 3px;
//     padding: 0;
//     display: flex;
//     justify-content: center;
//     align-items: center;
//     pointer-events: none;
//   }
// }
.launch-mp-btn {
  width: 220px;
  height: 45px;
  // background: #51afaf;
  // border-radius: 2.13vw;
  // font-size: 3.73vw;
  // font-weight: 400;
  // color: #ffffff;
  // letter-spacing: 3px;
  // padding: 0;
  // display: flex;
  // justify-content: center;
  // align-items: center;
}
</style>
```

微信 config 配置

```js
wx.config({
  ...res.data,
  debug: false,
  jsApiList: [
    "onMenuShareTimeline",
    "onMenuShareAppMessage",
    "onMenuShareQQ",
    "onMenuShareWeibo",
    "onMenuShareQZone",
    "chooseImage",
  ],
  openTagList: ["wx-open-launch-weapp"],
});
```

#### 注意事项

```js
<script type="text/wxtag-template"></script>
//  script中不能使用vw单位，否则会看不到按钮
```

### 微信通过渠道参数来访问 webview

```js
  onLoad(options) {
    console.log(options, "----");
    const { url } = options;
    // let url =
    //   "https%3A%2F%2Fmeta.kivisense.com%2Fcanada-goose-slt%2Findex.html%3F_um_campaign%3D64eddfe78efadc41dccf05a0%26_um_channel%3D64eddfe78efadc41dccf05a1";
    if (url) {
      let finalUrl = decodeURIComponent(url);
      console.log("finalUrl: ", finalUrl);
      let right = finalUrl.includes("https://");
      console.log("right: ", right);
      if (right) {
        this.setData({
          src: finalUrl,
        });
      }
    }
  },
```

### 正确使用权限

```js
  chosePhoto() {
    wx.getStorage({
      key: "is_check_privacy",
      success: () => {
        wx.showActionSheet({
          itemList: ["拍照", "从相册中选择"],
          success: (res) => {
            console.log(res.tapIndex);
            if (res.tapIndex === 0) {
              console.log("拍照");
              wx.getSetting({
                success: (res) => {
                  if (res.authSetting["scope.camera"]) {
                    // 用户已经授权
                    console.log("用户已经授权: ");
                    this.setData({
                      isCameraOpen: true,
                      trigger: "parent",
                    });
                  } else {
                    // 用户还没有授权，向用户发起授权请求
                    console.log("用户还没有授权，向用户发起授权请求: ");
                    wx.authorizeForMiniProgram({
                      scope: "scope.camera",
                      success: () => {
                        // 用户同意授权
                        // 打开相机组件
                        this.setData({
                          isCameraOpen: true,
                          trigger: "parent",
                        });
                      },
                      fail: () => {
                        // 用户不同意授权
                        showAuthModal("scope.camera", {
                          content: "需要使用“摄像头”权限",
                        });
                      },
                    });
                  }
                },
                fail: (res) => {
                  console.log("获取用户授权信息失败", res);
                  wx.showToast({
                    title: "获取用户授权信息失败",
                    icon: "none",
                    duration: 3000,
                  });
                },
              });
              stats("AIPaintingUploadPhotos_click_takePhoto");
            }
            if (res.tapIndex === 1) {
              this.setData({
                showModal: true,
              });
              stats("AIPaintingUploadPhotos_click_localAlbum");
            }
          },
          fail(res) {
            console.log(res.errMsg);
          },
        });
        stats("AIPaintingUploadPhotos_click_photo");
      },
      fail: () => {
        this.setData({
          showPrivacyModal: true,
          isCheckPrivacy: false,
        });
      },
    });
  },
```

弹起授权弹窗

```js
export async function showAuthModal(scope, config = { content: "" }) {
  try {
    const defaultConfig = {
      title: "提示",
      confirmText: "立即授权",
      confirmColor: "#02BB00",
    };

    const { confirm, cancel } = await promisify(wx.showModal)({
      ...defaultConfig,
      ...config,
    });
    if (confirm) {
      const {
        authSetting: { [scope]: isAuth },
      } = await promisify(wx.openSetting)();
      if (!isAuth) {
        return await showAuthModal(scope, config);
      }
      return true;
    } else if (cancel) {
      return false;
    } else {
      throw new Error("未知问题");
    }
  } catch (e) {
    console.error(e);
    return false;
  }
}

export function promisify(fn, context) {
  return (...config) => {
    return new Promise((resolve, reject) => {
      config[0] = {
        ...config[0],
        success: resolve,
        fail: reject,
      };
      const result = fn.apply(context || wx, config);
      if (config && typeof config.result === "function") {
        config.result(result);
      }
    });
  };
}

export function downloadFile(url, onProgress = () => {}) {
  const progressCallBack = (res) => {
    onProgress({ loaded: res.progress, total: 100 });
  };
  return new Promise((resolve, reject) => {
    const downloadTask = wx.downloadFile({
      url,
      success({ statusCode, tempFilePath }) {
        if (statusCode === 200) {
          resolve(tempFilePath);
        } else {
          reject(new Error(`下载文件(${url})失败, statusCode: ${statusCode}`));
        }
      },
      fail: reject,
      complete: () => {
        downloadTask.offProgressUpdate(progressCallBack);
      },
    });
    downloadTask.onProgressUpdate(progressCallBack);
  });
}

export function requestFile(
  url,
  onProgress = () => {},
  responseType = "arraybuffer"
) {
  return new Promise((resolve, reject) => {
    onProgress({ loaded: 0.2, total: 1 });
    wx.request({
      url,
      responseType,
      success({ statusCode, data }) {
        if (statusCode === 200) {
          onProgress({ loaded: 1, total: 1 });
          resolve(data);
        } else {
          reject(new Error(`下载文件(${url})失败, statusCode: ${statusCode}`));
        }
      },
      fail: reject,
    });
  });
}
```

### 另一种调用权限

```js
export async function askForAuth(
  scope,
  config = { content: "需要授权才能继续操作" }
) {
  let res = await promisify(wx.getSetting)();
  if (res.authSetting[scope]) return true;

  res = await new Promise((resolve) => {
    wx.authorize({
      scope,
      success: () => resolve(true),
      fail: () => resolve(false),
    });
  });
  if (res) return true;
  return showAuthModal(scope, config);
}

export async function showAuthModal(scope, config = { content: "" }) {
  try {
    const defaultConfig = {
      title: "提示",
      confirmText: "立即授权",
      confirmColor: "#02BB00",
    };

    const { confirm } = await promisify(wx.showModal)({
      ...defaultConfig,
      ...config,
    });
    if (confirm) {
      const {
        authSetting: { [scope]: isAuth },
      } = await promisify(wx.openSetting)();
      if (isAuth) {
        return true;
      }
      return await showAuthModal(scope, config);
    }
    return false;
  } catch (e) {
    console.error(e);
    return false;
  }
}


export function promisify(fn, context) {
  return (...config) => {
    return new Promise((resolve, reject) => {
      config[0] = {
        ...config[0],
        success: resolve,
        fail: reject,
      };
      const result = fn.apply(context || wx, config);
      if (config && typeof config.result === "function") {
        config.result(result);
      }
    });
  };
}
```

使用

```js
 const res = await askForAuth("scope.bluetooth", {
      content: "需要使用“蓝牙”权限",
    });
    if (!res) {
      wx.showModal({
        title: "提示",
        content: "无法获取蓝牙权限，将退回首页",
        showCancel: false,
        success: () => {
          wx.navigateBack({
            delta: 1,
          });
        },
      });
      return;
    }
```

### 插件使用与调试

#### 本地示例小程序中使用插件

app.json 中的使用区别

```json
{
  "pages": ["pages/index/index"],
  "plugins": {
    "chaumet": {
      "version": "dev",
      "provider": "wx2829a059adc932bd"
    }
  },
  "sitemapLocation": "sitemap.json"
}
```

#### 其他小程序使用开发版插件

```json
{
  "pages": ["pages/index/index"],
  "plugins": {
    "chaumet": {
      "version": "dev-5007f4fc31b382b21d40c1101d1bf5c2",
      "provider": "wx2829a059adc932bd"
    }
  },
  "sitemapLocation": "sitemap.json"
}
```

#### 其他小程序使用正式版插件

```json
{
  "pages": ["pages/index/index"],
  "plugins": {
    "chaumet": {
      "version": "1.0.0",
      "provider": "wx2829a059adc932bd"
    }
  },
  "sitemapLocation": "sitemap.json"
}
```

### 获取一个 node 节点

```js
const res = await new Promise((resolve) => {
  this.createSelectorQuery()
    .select(".canvas")
    .fields({
      node: true,
      size: true,
    })
    .exec((els) => resolve(els[0]));
});
const canvas = res.node;
```


### 使用canvas下载网络图片


```html
<view class="canvas-container">
  <canvas
    type="2d"
    id="offsetCanvas"
    style="width:{{canvasPixelWidth}}px;height:{{canvasPixelHeight}}px"
  />
</view>
```

```css
.canvas-container {
  position: fixed;
  top: -9999px;
  left: -9999px;
  width: 100vw;
  height: 100vh;
}
```

```js
/**
 * @description
 * 组件使用：
 * 当外部传入url不为空字符串时，则会触发saveImageByCanvas从而保存网路图片到相册，
 * 组件会在保存相册成功后，抛出finish事件。
 * -----------
 * 可以通过exportType字段设定导出图片模式：
 * origin模式：按照图片原始比例保存到相册；
 * custom模式：可以指定width和height，保存到相册的图片根据指定宽高来居中裁剪。
 */

Component({
  properties: {
    url: {
      type: String,
      value: "",
    },
    // 组件传递过来的宽高如果大于手机屏幕本身的宽高，
    // 会被等比例缩放至屏幕相近的大小。
    width: {
      type: Number,
      value: wx.getSystemInfoSync().windowWidth,
    },
    height: {
      type: Number,
      value: wx.getSystemInfoSync().windowHeight,
    },
    // origin:根据图片的原始尺寸导出(默认值)
    // custom:根据properties.width和properties.height的值导出
    exportType: {
      type: String,
      value: "origin",
    },
  },

  data: {
    ctx: null,
    canvas: null,

    screenWidth: wx.getSystemInfoSync().windowWidth,
    screenHeight: wx.getSystemInfoSync().windowHeight,

    canvasPixelWidth: wx.getSystemInfoSync().windowWidth,
    canvasPixelHeight: wx.getSystemInfoSync().windowHeight,
  },

  observers: {
    url: function (u) {
      if (u) {
        this.saveImageByCanvas(u);
      }
    },
  },

  methods: {
    async saveImageByCanvas(url) {
      const { path, width, height } = await wx.getImageInfo({
        src: url,
      });

      this.setCanvasSize(width, height);

      const nodeList = await this.getNode("#offsetCanvas");

      this.makeCanvasDisplayBetter(nodeList[0]);

      this.drawImageThenExport(path);
    },

    setCanvasSize(width, height) {
      let w =
        this.properties.exportType === "origin" ? width : this.properties.width;
      let h =
        this.properties.exportType === "origin"
          ? height
          : this.properties.height;

      const { shortW, shortH } = this.calcCanvasSize(w, h);

      this.setData({
        canvasPixelWidth: shortW,
        canvasPixelHeight: shortH,
      });
    },

    calcCanvasSize(w, h) {
      // 如果canvas上的style内联width/height非常大，那么，真机上绘制图片时，可能会白屏
      // https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html
      // 简单测试了下，大概安全宽度和高度是：900*1350，
      // 即：如果canvas的内联样式宽度在900以内，高度在1350以内，真机可以正常渲染
      // 此处为了兼容性，函数会直接将canvas的内联宽高缩放至屏幕大小
      if (w > this.data.screenWidth || h > this.data.screenHeight) {
        let screenRatio = this.data.screenWidth / this.data.screenHeight;
        let selfRatio = w / h;
        if (screenRatio > selfRatio) {
          w = (w * this.data.screenHeight) / h;
          h = this.data.screenHeight;
        } else {
          h = (h * this.data.screenWidth) / w;
          w = this.data.screenWidth;
        }
      }
      return { shortW: w, shortH: h };
    },

    getNode(id) {
      return new Promise((res, rej) => {
        const query = wx.createSelectorQuery().in(this);
        query
          .select(id)
          .fields({ node: true, size: true })
          .exec((e) => {
            if (e[0]) {
              res(e);
            } else {
              rej(e);
            }
          });
      });
    },

    makeCanvasDisplayBetter(nodeInfo) {
      const { node: canvas } = nodeInfo;
      const { pixelRatio } = wx.getSystemInfoSync();
      const ctx = canvas.getContext("2d");
      // 此处将canvas的尺寸扩大（3倍）,缩放扩大（3倍），
      // 并且在style内联样式中又指定canvas的宽（1倍）和高（1倍），来实现更清晰的canvas显示效果。
      // 原理：生成3倍大小canvas，通过css缩放到1倍宽高的dom中显示。
      // 相当于将900*900的图片，展示到一个300*300大小的dom框中，清晰度会提高。
      // 微信小程序会显示canvas的最大尺寸为：4096*4096，超出会报错
      const dpr = this.calcDPR(pixelRatio);
      canvas.width = this.data.canvasPixelWidth * dpr;
      canvas.height = this.data.canvasPixelHeight * dpr;
      ctx.scale(dpr, dpr);
      this.setData({
        canvas,
        ctx,
      });
    },

    calcDPR(pixelRatio) {
      let dpr = pixelRatio;
      if (
        this.data.canvasPixelWidth * pixelRatio > 4096 ||
        this.data.canvasPixelHeight * pixelRatio > 4096
      ) {
        const shortDPR = this.calcDPR(pixelRatio - 1);
        return shortDPR;
      } else {
        return dpr;
      }
    },

    drawImageThenExport(path) {
      let imgObj = this.data.canvas.createImage();
      imgObj.onload = () => {
        if (imgObj.complete) {
          this.drawImage(imgObj);
          this.saveFileToAlbum();
        }
      };
      imgObj.src = path;
    },

    drawImage(imgObj) {
      const { sx, sy, sWidth, sHeight } = this.calcDrawDistance(imgObj);
      this.data.ctx.drawImage(
        imgObj,
        sx,
        sy,
        sWidth,
        sHeight,
        0,
        0,
        this.data.canvasPixelWidth, // 这个值会根据比例自动缩放，所以不需要乘以dpr
        this.data.canvasPixelHeight
      );
    },

    calcDrawDistance(imgObj) {
      let sWidth = 0;
      let sHeight = 0;
      let sx = 0;
      let sy = 0;
      let imageRatio = imgObj.width / imgObj.height;
      let screenRatio =
        this.data.canvasPixelWidth / this.data.canvasPixelHeight;
      if (imageRatio >= screenRatio) {
        sWidth =
          (this.data.canvasPixelWidth * imgObj.height) /
          this.data.canvasPixelHeight;
        sHeight = imgObj.height;
        sx = (imgObj.width - sWidth) / 2;
        sy = 0;
      } else {
        sWidth = imgObj.width;
        sHeight =
          (this.data.canvasPixelHeight * imgObj.width) /
          this.data.canvasPixelWidth;
        sx = 0;
        sy = (imgObj.height - sHeight) / 2;
      }
      return {
        sx,
        sy,
        sWidth,
        sHeight,
      };
    },

    saveFileToAlbum() {
      wx.canvasToTempFilePath({
        x: 0,
        y: 0,
        canvas: this.data.canvas,
        success: (res) => {
          wx.saveImageToPhotosAlbum({
            filePath: res.tempFilePath,
            success: () => {
              this.triggerEvent("finish");
            },
          });
        },
      });
    },
  },
});

```

### 使用canvas生成海报

外部使用
```js
this.generateImageByCanvas("generate");
this.generateImageByCanvas("save");

generateImageByCanvas(action) {
      let updateList = [
        {
          type: "image",
          url: getStaticUrl("qr-code/test_bc.png"),
          dx: 0,
          dy: 0,
          dWidth: this.data.canvasWidth,
          dHeight: this.data.canvasHeight,
          mode: "aspectFill",
        },
        {
          type: "image",
          url: this.properties.currentCollectCardDetail.url,
          dy: 73,
          dWidth: 175.2,
          dHeight: 204,
          mode: "screenCenter",
          borderRadius: 10,
          borderColor: "#E0C069",
          objectFit: "aspectFill",
        },
        {
          type: "text",
          content: this.properties.currentCollectCardDetail.name,
          dy: 300,
          font: "16px",
          fillStyle: "#897160",
          mode: "screenCenter",
          letterSpacing: 1,
        },
        {
          type: "multilineText",
          content: this.properties.currentCollectCardDetail.description,
          dx: 44,
          dy: 320,
          font: "12px",
          fillStyle: "#C2A272",
          line: 4,
          lineHeight: 18,
          maxWidth: 245,
          letterSpacing: 0.5,
        },
        {
          type: "image",
          url: getStaticUrl("qr-code/mini_code_circle.png"),
          dy: 400,
          dWidth: 70,
          dHeight: 70,
          mode: "screenCenter",
        },
        {
          type: "text",
          content: "扫码开启 奇幻之旅",
          dy: 484,
          font: "11px",
          fillStyle: "#897160",
          letterSpacing: 1,
          mode: "screenCenter",
        },
      ];
      this.setData({
        saveDomOptions: updateList,
        action: action,
      });
    },
```

```js
/**
 * @description
 * 组件使用：
 * 组件会在保存相册成功后，抛出finish事件。
 * -----------
 * options的配置项：
 *   type: "multilineText/text/image", // 绘制类型，支持字符和图片
 *   url:'', // 图片地址
 *   content: '', // 文字内容
 *   dx: 44, // 距离左边距
 *   dy: 300, // 距离上边距
 *   dWidth: 200, // 绘制的图片宽度
 *   dHeight: 200, // 绘制的图片高度
 *   font: "12px", // 字体大小
 *   fillStyle: "#C2A272", //字体颜色
 *   textAlign:'', // 字体位置
 *   textBaseline:"", // 字体基线
 *   line: 4, // 多行文字行数
 *   lineHeight:20, // 多行文字行高
 *   maxWidth: 245, // 文字绘制的最大宽度
 *   letterSpacing: 0.5, // 文字间距
 *   mode: "screenCenter", // screenCenter：文字屏幕居中
 *   objectFit:'aspectFill', // aspectFill：图片适配裁剪模式；
 *   borderRadius: 10, // 圆角
 *   borderColor: "#E0C069", // 边框颜色
 */

Component({
  properties: {
    options: {
      type: Array,
      value: () => {},
    },
    // show: {
    //   type: Boolean,
    //   value: false,
    // },
    width: {
      type: Number,
      value: wx.getSystemInfoSync().windowWidth,
    },
    height: {
      type: Number,
      value: wx.getSystemInfoSync().windowHeight,
    },
    action: {
      type: String,
      value: "save",
    },
  },

  data: {
    show: true,
    ctx: null,
    canvas: null,

    // 手机屏幕本身的宽和高
    screenWidth: wx.getSystemInfoSync().windowWidth,
    screenHeight: wx.getSystemInfoSync().windowHeight,

    // 用户通过properties.width和height定义的width和height
    canvasPixelWidth: wx.getSystemInfoSync().windowWidth,
    canvasPixelHeight: wx.getSystemInfoSync().windowHeight,

    pixelRatio: wx.getSystemInfoSync().pixelRatio,
  },

  observers: {
    options: function (n) {
      console.log("n: ", n);
      if (n.length > 0) {
        this.setData({
          show: true,
        });
        wx.showLoading({
          title: this.properties.action === "save" ? "保存中" : "生成中",
          mask: true,
        });
        wx.nextTick(() => {
          this.saveImageByCanvas();
        });
      }
    },
  },

  methods: {
    async saveImageByCanvas() {
      if (!this.properties.width || !this.properties.height) {
        console.log("%c----需要设定海报的宽高----", "color: yellow;");
        return;
      }
      this.setCanvasSize();

      const nodeList = await this.getNode("#saveDomOffsetCanvas");

      this.makeCanvasDisplayBetter(nodeList[0]);

      // 绘制前，先清空一次
      this.clearCanvas();

      for (let index = 0; index < this.properties.options.length; index++) {
        let element = this.properties.options[index];
        // 绘制图片
        if (element.type === "image") {
          await this.drawImageByCreateImage(element);
        }
        // 绘制单行字
        if (element.type === "text") {
          await this.fillSingleTextByCanvas(element);
        }
        // 绘制多行字
        if (element.type === "multilineText") {
          await this.fillMultilineTextByCanvas(element);
        }
      }

      if (this.properties.action === "save") {
        this.saveFileToAlbum();
      }
      if (this.properties.action === "generate") {
        this.justGenerateImageAndReturnPath();
      }
    },

    // ----------------------渲染函数------------------------

    fillMultilineTextByCanvas(item) {
      // eslint-disable-next-line no-unused-vars
      return new Promise((res, rej) => {
        this.data.ctx.font = item.font ? item.font + " Arial" : "22px Arial";
        this.data.ctx.fillStyle = item.fillStyle || "#C2A272";
        if (item.line) {
          this.drawMultilineText(item);
        } else {
          console.log("%c----需要设定多行文字行数----", "color: yellow;");
        }
        res(true);
      });
    },

    fillSingleTextByCanvas(item) {
      // eslint-disable-next-line no-unused-vars
      return new Promise((res, rej) => {
        this.setFontStyle(item);
        this.drawText(item);
        res(true);
      });
    },

    drawImageByCreateImage(item) {
      // eslint-disable-next-line no-unused-vars
      return new Promise((res, rej) => {
        let imgObj = this.data.canvas.createImage();
        imgObj.onload = () => {
          if (imgObj.complete) {
            this.drawImage(imgObj, item);
            res(imgObj);
          }
        };
        imgObj.src = item.url;
      });
    },

    drawImage(imgObj, item) {
      // 如果绘制的图片是屏幕居中，则需要手动赋值dx
      if (item.mode === "screenCenter") {
        let dx = (this.data.canvasPixelWidth - item.dWidth) / 2;
        Object.assign(item, {
          dx: dx,
        });
      }
      if (item.mode === undefined && item.dx === undefined) {
        console.log(
          "%c----不是屏幕居中（screenCenter）情况下，需要设置dx属性----",
          "color: yellow;"
        );
        console.log(`%c---${item.url}`, "color: yellow;");
      }
      if (item.borderRadius) {
        // 如果有边框，需要先绘制圆角图片，再绘制圆角矩形
        this.drawRadiusRectImage(imgObj, item);
        this.drawBorder(item);
      } else {
        this.calcThenDrawImage(imgObj, item);
      }
    },

    // ------------------工具函数-----------------
    setFontStyle(item) {
      this.data.ctx.font = item.font ? item.font + " Arial" : "22px Arial";
      this.data.ctx.fillStyle = item.fillStyle || "#C2A272";
      this.data.ctx.textAlign = item.textAlign || "start";
      this.data.ctx.textBaseline = item.textBaseline || "middle";
    },

    drawMultilineText(item) {
      this.getWrapText(item).forEach((e) => {
        // 多行文字绘制，需要固定为 start和top
        Object.assign(item, {
          textAlign: "start",
          textBaseline: "top",
        });
        this.setFontStyle(item);
        this.drawText(e);
      });
    },

    drawText(item) {
      if (item.letterSpacing > 0) {
        // 如果有letterSpacing字间距，则通过逐字形式来渲染
        let totalWidth = item.dx; // 渲染字符的起始dx位置
        if (!item.dx) {
          console.log(
            "%c----如果没有传入dx字段，则会默认屏幕居中----",
            "color: yellow;"
          );
          console.log(`%c${item.content}-未设置dx的值`, "color: yellow;");
          let strWidth = this.data.ctx.measureText(item.content).width;
          totalWidth =
            (this.data.canvasPixelWidth -
              strWidth -
              item.letterSpacing * (item.content.length - 1)) /
            2;
        }
        // 根据letterSpacing逐字渲染出来
        for (let i = 0; i < item.content.length; i++) {
          this.data.ctx.fillText(item.content[i], totalWidth, item.dy);
          totalWidth +=
            this.data.ctx.measureText(item.content[i]).width +
            item.letterSpacing;
        }
      } else {
        // 如果没有letterSpacing，则直接fillText形式渲染，节省性能
        if (item.mode === "screenCenter") {
          // 文字相对于屏幕居中
          this.data.ctx.textAlign = "center";
          this.data.ctx.fillText(
            item.content,
            this.data.canvasPixelWidth / 2,
            item.dy
          );
        } else {
          this.data.ctx.fillText(item.content, item.dx, item.dy);
        }
      }
    },

    getWrapText(item) {
      let lineHeight = item.lineHeight || 20;
      let letterSpacing = item.letterSpacing || 0;
      let txtList = [];
      let str = "";
      for (let i = 0, len = item.content.length; i < len; i++) {
        str += item.content.charAt(i);
        if (
          this.data.ctx.measureText(str).width +
            letterSpacing * (str.length - 1) >
          item.maxWidth
        ) {
          let textInfo = {
            type: "text",
            font: item.font,
            fillStyle: item.fillStyle,
            content: str.substring(0, str.length - 1),
            dx: item.dx,
            dy: item.dy + lineHeight * txtList.length,
            mode: item.mode || "",
            maxWidth: item.maxWidth,
            letterSpacing: item.letterSpacing,
          };
          txtList.push(textInfo);
          str = "";
          i--;
        }
      }
      txtList.push({
        type: "text",
        font: item.font,
        fillStyle: item.fillStyle,
        content: str,
        dx: item.dx,
        dy: item.dy + lineHeight * txtList.length,
        mode: item.mode || "",
      });
      if (txtList.length >= item.line) {
        let index = item.line - 1;
        let lastTextItem = txtList[index]["content"];
        let penultimateStr = lastTextItem[lastTextItem.length - 2];
        let curEndIndex = -1;
        // 如果倒数第二个字刚好也是标点符号，则直接将其去掉
        if (
          this.patchZhMark(penultimateStr) ||
          this.patchEnMark(penultimateStr)
        ) {
          curEndIndex = -2;
        }
        Object.assign(txtList[index], {
          content: lastTextItem.slice(0, curEndIndex) + "...",
        });
      }
      let finalTxtList = txtList.splice(0, item.line);
      return finalTxtList;
    },

    drawRadiusRectImage(imgObj, item) {
      // 绘制圆角图片原理：
      // 1.先保存当前画面，
      // 2.裁剪出圆角矩形画布，
      // 3.绘制图片，
      // 4.恢复裁剪之前的画面
      this.data.ctx.save(); // 保存
      this.drawRadiusRect(
        item.dx,
        item.dy,
        item.dWidth,
        item.dHeight,
        item.borderRadius
      ); // 画出圆角画布
      this.data.ctx.clip(); // 裁剪
      this.calcThenDrawImage(imgObj, item); // 绘图
      this.data.ctx.restore(); // 恢复裁剪前的画面
    },

    drawBorder(item) {
      this.data.ctx.strokeStyle = item.borderColor || "#E0C069";
      this.drawRadiusRect(
        item.dx,
        item.dy,
        item.dWidth,
        item.dHeight,
        item.borderRadius
      );
      this.data.ctx.stroke();
    },

    calcThenDrawImage(imgObj, item) {
      const { sx, sy, sWidth, sHeight } = this.calcDrawDistance(imgObj, item);
      this.data.ctx.drawImage(
        imgObj,
        sx,
        sy,
        sWidth,
        sHeight,
        item.dx,
        item.dy,
        item.dWidth,
        item.dHeight
      );
    },

    calcDrawDistance(imgObj, item) {
      let sx = 0;
      let sy = 0;
      //  通常情况下，我们传入的图片宽高就是需要绘制到canvas上的宽高
      let sWidth = item.dWidth;
      let sHeight = item.dHeight;

      if (item.objectFit === "aspectFill") {
        // 裁剪模式一般是图片本身大小和需要显示出来的大小不匹配，需要裁剪一部分，
        let imageRatio = imgObj.width / imgObj.height;
        let screenRatio = item.dWidth / item.dHeight;
        if (imageRatio >= screenRatio) {
          sWidth = (item.dWidth * imgObj.height) / item.dHeight;
          sHeight = imgObj.height;
          sx = (imgObj.width - sWidth) / 2;
          sy = 0;
        } else {
          sWidth = imgObj.width;
          sHeight = (item.dHeight * imgObj.width) / item.dWidth;
          sx = 0;
          sy = (imgObj.height - sHeight) / 2;
        }
        return {
          sx,
          sy,
          sWidth,
          sHeight,
        };
      } else {
        sWidth = imgObj.width;
        sHeight = imgObj.height;
        return {
          sx,
          sy,
          sWidth,
          sHeight,
        };
      }
    },

    setCanvasSize() {
      this.setData({
        canvasPixelWidth: this.properties.width,
        canvasPixelHeight: this.properties.height,
      });
    },

    calcCanvasSize(w, h) {
      // 如果canvas上的style内联width/height非常大，那么，真机上绘制图片时，可能会白屏
      // https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html
      // 渲染高度限制：IOS实际像素 < 4096，实际高度需 < 4096/3 = 1356
      // 即：如果canvas的内联样式宽/高度在1350以内，真机可以正常渲染
      // 此处为了兼容性，函数会直接将canvas的内联宽高缩放至屏幕大小
      if (w > this.data.screenWidth || h > this.data.screenHeight) {
        let screenRatio = this.data.screenWidth / this.data.screenHeight;
        let selfRatio = w / h;
        if (screenRatio > selfRatio) {
          w = (w * this.data.screenHeight) / h;
          h = this.data.screenHeight;
        } else {
          h = (h * this.data.screenWidth) / w;
          w = this.data.screenWidth;
        }
      }
      return { w, h };
    },

    getNode(id) {
      return new Promise((res, rej) => {
        const query = wx.createSelectorQuery().in(this);
        query
          .select(id)
          .fields({ node: true, size: true })
          .exec((e) => {
            if (e[0]) {
              res(e);
            } else {
              rej(e);
            }
          });
      });
    },

    makeCanvasDisplayBetter(nodeInfo) {
      const { node: canvas } = nodeInfo;
      const ctx = canvas.getContext("2d");
      // 此处将canvas的尺寸扩大（3倍）,缩放扩大（3倍），
      // 并且在style内联样式中又指定canvas的宽（1倍）和高（1倍），来实现更清晰的canvas显示效果。
      // 原理：生成3倍大小canvas，通过css缩放到1倍宽高的dom中显示。
      // 相当于将900*900的图片，展示到一个300*300大小的dom框中，清晰度会提高。
      // 微信小程序会显示canvas的最大尺寸为：4096*4096，超出会报错
      const dpr = this.calcDPR(this.data.pixelRatio);
      canvas.width = this.data.canvasPixelWidth * dpr;
      canvas.height = this.data.canvasPixelHeight * dpr;
      ctx.scale(dpr, dpr);
      this.setData({
        canvas,
        ctx,
      });
    },

    calcDPR(pixelRatio) {
      let dpr = pixelRatio;
      if (
        this.data.canvasPixelWidth * pixelRatio > 4096 ||
        this.data.canvasPixelHeight * pixelRatio > 4096
      ) {
        const shortDPR = this.calcDPR(pixelRatio - 1);
        return shortDPR;
      } else {
        return dpr;
      }
    },

    saveFileToAlbum() {
      wx.canvasToTempFilePath({
        x: 0,
        y: 0,
        canvas: this.data.canvas,
        success: (res) => {
          wx.saveImageToPhotosAlbum({
            filePath: res.tempFilePath,
            success: () => {
              this.triggerEvent("finish");
              this.setData({
                show: false,
              });
            },
            complete: () => {
              wx.hideLoading();
            },
          });
        },
      });
    },

    justGenerateImageAndReturnPath() {
      wx.canvasToTempFilePath({
        x: 0,
        y: 0,
        canvas: this.data.canvas,
        success: (res) => {
          if (res.tempFilePath) {
            this.triggerEvent("filepath", res.tempFilePath);
            this.setData({
              show: false,
            });
          } else {
            console.log("生图失败");
          }
        },
        complete: () => {
          wx.hideLoading();
        },
      });
    },

    drawRadiusRect(x, y, w, h, r) {
      const br = r;
      let ctx = this.data.ctx;
      ctx.beginPath();
      ctx.moveTo(x + br, y); // 移动到左上角的点
      ctx.lineTo(x + w - br, y); // 画上边的线
      ctx.arcTo(x + w, y, x + w, y + br, br); // 画右上角的弧
      ctx.lineTo(x + w, y + h - br); // 画右边的线
      ctx.arcTo(x + w, y + h, x + w - br, y + h, br); // 画右下角的弧
      ctx.lineTo(x + br, y + h); // 画下边的线
      ctx.arcTo(x, y + h, x, y + h - br, br); // 画左下角的弧
      ctx.lineTo(x, y + br); // 画左边的线
      ctx.arcTo(x, y, x + br, y, br); // 画左上角的弧
      ctx.closePath();
    },

    //判断字符是否是 中文符号
    patchZhMark(temp) {
      var reg =
        /[\u3002|\uff1f|\uff01|\uff0c|\u3001|\uff1b|\uff1a|\u201c|\u201d|\u2018|\u2019|\uff08|\uff09|\u300a|\u300b|\u3008|\u3009|\u3010|\u3011|\u300e|\u300f|\u300c|\u300d|\ufe43|\ufe44|\u3014|\u3015|\u2026|\u2014|\uff5e|\ufe4f|\uffe5]/;
      if (reg.test(temp)) {
        return true;
      } else {
        return false;
      }
    },

    //判断字符是否是 英文半角符号
    patchEnMark(temp) {
      var reg = /[\x21-\x2f\x3a-\x40\x5b-\x60\x7B-\x7F]/;
      if (reg.test(temp)) {
        return true;
      } else {
        return false;
      }
    },

    clearCanvas() {
      this.data.ctx.clearRect(
        0,
        0,
        this.data.canvasPixelWidth,
        this.data.canvasPixelHeight
      );
    },

    // ------------------功能函数-----------------
  },
});

```


```css
.save-dom-canvas-container {
  position: fixed;
  top: -9999px;
  left: -9999px;
  width: 100vw;
  height: 100vh;
}
```

```html
<view class="save-dom-canvas-container" wx:if="{{show}}">
  <canvas
    type="2d"
    id="saveDomOffsetCanvas"
    style="width:{{canvasPixelWidth}}px;height:{{canvasPixelHeight}}px"
  />
</view>
```


### 下拉刷新组件

```html
<scroll-view
  scroll-y
  enable-passive="{{true}}"
  enhanced="{{true}}"
  bounces="{{false}}"
  fast-deceleration="{{true}}"
  refresher-enabled="{{true}}"
  lower-threshold="{{100}}"
  refresher-threshold="{{refresherThresholdHeight}}"
  refresher-default-style="none"
  refresher-triggered="{{triggered}}"
  style="height:{{contentHeight}}"
  bindrefresherrefresh="onDefaultRefresh"
  bindrefresherpulling="onPulling"
  bindrefresherrestore="onRestore"
  bindscrolltolower="onLoadmore"
  bind:touchend="dragend"
>
  <!-- scroll-view 自定义下拉刷新节点需要声明为 slot="refresher" -->
  <view slot="refresher" class="refresh-container">
    <view class="bottom-refresh-container" style="height:{{refresherThresholdHeight}}px">
      <image src="{{refreshLogo}}" mode="aspectFit" class="bottom-refresh-bc-image" />
      <block wx:if="{{refreshstate == 'pulldown'}}">下拉刷新</block>
      <block wx:elif="{{refreshstate == 'loosen'}}">松手刷新</block>
      <block wx:elif="{{refreshstate == 'loading'}}">刷新中...</block>
    </view>
  </view>
  <!-- bounces： ios上该属性需要关闭，否则会导致第二次下拉刷新时，屏幕抖动 -->
  <!-- 在ios中，当view overflow:auto时，view在下拉到顶部或者底部时会有一部分弹性距离，但是当这个view内有setData发生时，view会立即复原，从而导致你在拉到底部时弹性距离刚出现一部分又被setData复原了 ，如果一直拉住不放就会一直重复这个过程，所有在我们看来就是页面在疯狂的抖动了-->
  <slot></slot>
</scroll-view>
```

```css
.refresh-container {
  display: flex;
  flex-flow: column nowrap;
  align-items: center;
  justify-content: flex-end;
  width: 100%;
  height: 100vh;
  background-color: #fff;

  /* background: linear-gradient(
    180deg,
    #ffe7b9 12.78%,
    #fff2d8 22.45%,
    #fffbf2 32.77%,
    #fffbf2 78.45%,
    #fff 87.05%
  ); */
}

.bottom-refresh-container {
  position: relative;
  display: flex;
  flex-flow: column nowrap;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 80px;
  color: #d2ab64;
  font-weight: 500;
  font-size: 15px;
  letter-spacing: 1px;
}

.bottom-refresh-bc-image {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 80%;
  height: 40px;
  transform: translate(-50%, -50%);
  opacity: 0.1;
}

```

```js
const { getStaticUrl } = require("@/utils/assets");

Component({
  options: {},
  properties: {
    contentHeight: {
      type: String,
      value: "500px",
    },
  },
  data: {
    timeout: null,
    triggered: false,
    refreshstate: "pulldown",
    refreshLogo: getStaticUrl("header/full_name_with_bg_short.png"),
    refresherThresholdHeight: 80,
  },
  ready() {},
  methods: {
    debounce(fn, wait) {
      let that = this;
      this.setData({
        timeout: null,
      });
      return function () {
        if (that.data.timeout !== null) {
          clearTimeout(that.data.timeout);
        }
        const timeout = setTimeout(() => {
          fn();
        }, wait);
        that.setData({
          timeout,
        });
      };
    },
    onLoadmore() {
      this.debounce(() => {
        this.triggerEvent("loadmore");
        wx.vibrateShort();
      }, 500)();
    },

    onPulling(evt) {
      let p = Math.min(
        evt.detail.dy / (this.data.refresherThresholdHeight + 20),
        1
      );
      this.p = p ? p : 0;
      if (p >= 0.8) {
        this.setData({
          refreshstate: "loosen",
        });
      } else {
        this.setData({
          refreshstate: "pulldown",
        });
      }
    },
    onDefaultRefresh() {
      wx.vibrateShort();
      this.triggerEvent("refresh");
      this.debounce(() => {
        this.settriggered(false);
      }, 1000)();
    },
    onRestore() {
      console.log("自定义下拉刷新被复位");
    },

    dragend() {
      if (this.p > 0.6 && this.data.refreshstate !== "loading") {
        this.setData({
          refreshstate: "loading",
        });
      } else {
        this.settriggered(false);
      }
    },

    settriggered(flag) {
      return new Promise((resolve) => {
        this.setData(
          {
            triggered: flag,
          },
          () => {
            resolve();
          }
        );
      });
    },
  },
});

```


#### 使用组件

```html
<scroller
  contentHeight="calc(100vh - 194.2308rpx)"
  bind:refresh="onReachTop"
  bind:loadmore="onReachBottom"
>
</scroller>
```


### 按顺序执行异步请求问题


### 约定了 loadLogin 特定周期，以解决发起请求的 token 获取顺序问题

使用场景：当一进入页面时，需要先发起 token 请求，等接口返回 token 后，再发起其他请求。

使用方式：

```js
  onLoad() {},
  onLoadLogin() {
     // index/index接口需要先获取token再发起请求，所以需要放入onLoadLogin周期中使用，
     //在此周期内发起的请求都已经携带了token
    Api.request("index/index", {}).then((result) => {
      console.log('首页接口:', result);
     });
  },
```

使用文档：[spa-custom-hooks](https://github.com/1977474741/spa-custom-hooks)


### 带点击效果的组件

```html
<view class="tap-hover-container" hover-class="hover-with-opacity-{{type}}" hover-stay-time="300">
  <slot></slot>
</view>
```

```css
.hover-with-opacity-scale {
  transform: scale(0.94, 0.94);
  opacity: 0.9;
  transition: all 0.3s;
}

.hover-with-opacity-bc {
  background: #f7f7f7;
  opacity: 0.9;
}

.tap-hover-container {
  width: 100%;
  height: 100%;
}
```

```js
Component({
  properties: {
    type: {
      type: String,
      value: "scale",
    },
  },
});
```


#### 使用


```html
<tap-hover-scale-container>
  <text>test</text>
</tap-hover-scale-container>
```


### 拖拽/缩放/旋转组件


```html
<!-- gesture-view.wxml -->
<view
  class="gesture-wrapper"
  catch:touchstart="touchStart"
  catch:touchmove="touchMove"
  catch:touchend="touchEnd"
  style="width: {{width}}; height: {{height}}; overflow: hidden;"
>
  <view id="gesture-ref" style="width: 0; height: 0"></view>
  <view
    class="content-container"
    style="width: {{width}}; height: {{height}}; transform: {{transform}}; transform-origin: 0 0;"
  >
    <slot></slot>
  </view>
</view>

```

```js
// gesture-view.js
const CSSMatrix = require("./dommatrix");

Component({
  /**
   * 组件的属性列表
   */
  properties: {
    width: {
      // 宽度
      type: String,
      value: "300rpx",
    },
    height: {
      // 高度
      type: String,
      value: "200rpx",
    },
    translateX: {
      // 是否开启横向移动，关闭请使用 translateX="{{false}}"
      type: Boolean,
      value: true,
    },
    translateXValue: {
      // 横向移动初始值，单位px
      type: Number,
      value: 0,
    },
    translateY: {
      // 是否开启纵向移动，关闭请使用 translateY="{{false}}"
      type: Boolean,
      value: true,
    },
    translateYValue: {
      // 纵向移动初始值，单位px
      type: Number,
      value: 0,
    },
    scale: {
      // 是否开启缩放，关闭请使用 scale="{{false}}"
      type: Boolean,
      value: true,
    },
    scaleValue: {
      // 缩放初始值
      type: Number,
      value: 1.0,
    },
    scaleMin: {
      // 缩放范围最小值
      type: Number,
      value: 0.1,
    },
    scaleMax: {
      // 缩放范围最大值
      type: Number,
      value: 2.0,
    },
    rotate: {
      // 是否开启旋转，关闭请使用 rotate="{{false}}"
      type: Boolean,
      value: true,
    },
    rotateValue: {
      // 旋转初始度数
      type: Number,
      value: 0,
    },
  },

  /**
   * 组件的初始数据
   */
  data: {
    startScale: -1,
    startDistance: -1,
    transform: "",
    transformMatrix: null,
    startTransformMatrix: null,
    startRotate: -1,
    startAngle: 0,
    startOrigin: { x: 0, y: 0 },
    startTouches: [],
  },

  observers: {
    transformMatrix: function (transformMatrix) {
      this.setData({
        transform: transformMatrix.toString(),
      });
    },
    translateYValue: function (y) {
      let initialTransformMatrix = new CSSMatrix()
        .scale(this.data.scaleValue)
        .rotate(this.data.rotateValue)
        .translate(this.data.translateXValue, y);
      this.setData({
        transformMatrix: initialTransformMatrix,
        startTransformMatrix: initialTransformMatrix,
      });
    },
  },

  lifetimes: {
    ready: function () {
      let initialTransformMatrix = new CSSMatrix()
        .scale(this.data.scaleValue)
        .rotate(this.data.rotateValue)
        .translate(this.data.translateXValue, this.data.translateYValue);
      this.setData({
        transformMatrix: initialTransformMatrix,
        startTransformMatrix: initialTransformMatrix,
      });
    },
  },

  /**
   * 组件的方法列表
   */
  methods: {
    getTouchDistance(touches) {
      return Math.hypot(
        touches[0].clientX - touches[1].clientX,
        touches[0].clientY - touches[1].clientY
      );
    },

    getTouchAngle(touches) {
      const x = touches[0].clientX - touches[1].clientX;
      const y = touches[0].clientY - touches[1].clientY;
      return (Math.atan2(y, x) * 180) / Math.PI;
    },

    midpoint(touches) {
      let [t1, t2] = touches;
      return {
        x: (t1.clientX + t2.clientX) / 2,
        y: (t1.clientY + t2.clientY) / 2,
      };
    },

    touchStart: function (e) {
      const touches = e.touches;
      this.data.startTouches = touches;
      if (touches.length === 2) {
        let startOrigin = this.midpoint(touches);
        const that = this;
        // #gesture-ref is of no transform
        this.createSelectorQuery()
          .select("#gesture-ref")
          .boundingClientRect(function (rect) {
            startOrigin = {
              x: startOrigin.x - rect.left,
              y: startOrigin.y - rect.top,
            };
            that.setData({
              startOrigin,
              startDistance: that.getTouchDistance(touches),
              startAngle: that.getTouchAngle(touches),
            });
          })
          .exec();
      }
      this.setData({
        startRotate: this.data.rotateValue,
        startScale: this.data.scaleValue,
        startTransformMatrix: this.data.transformMatrix,
      });
    },

    touchMove: function (e) {
      const touches = e.touches;
      const { startTouches, startScale, startRotate, startAngle } = this.data;
      if (touches.length === 2 && startTouches.length === 2) {
        let curScale = startScale,
          delta_scale = 1.0;
        if (this.data.scale) {
          curScale =
            startScale *
            (this.getTouchDistance(touches) / this.data.startDistance);
          if (curScale < this.data.scaleMin) curScale = this.data.scaleMin;
          if (curScale > this.data.scaleMax) curScale = this.data.scaleMax;
          delta_scale = curScale / startScale;
        }

        let curRotate = startRotate,
          delta_rotate = 0.0;
        if (this.data.rotate) {
          delta_rotate = this.getTouchAngle(touches) - startAngle;
          curRotate = startRotate + delta_rotate;
        }

        const mp_init = this.midpoint(startTouches);
        const mp_cur = this.midpoint(touches);
        const translateX = this.data.translateX ? mp_cur.x - mp_init.x : 0;
        const translateY = this.data.translateY ? mp_cur.y - mp_init.y : 0;

        let transformMatrix = new CSSMatrix()
          .translate(this.data.startOrigin.x, this.data.startOrigin.y)
          .translate(translateX, translateY)
          .rotate(delta_rotate)
          .scale(delta_scale)
          .translate(-this.data.startOrigin.x, -this.data.startOrigin.y)
          .multiply(this.data.startTransformMatrix);

        this.setData({
          scaleValue: curScale,
          rotateValue: curRotate,
          transformMatrix: transformMatrix,
        });
      } else if (startTouches.length !== 2) {
        let transformMatrix = new CSSMatrix()
          .translate(
            this.data.translateX
              ? touches[0].clientX - startTouches[0].clientX
              : 0,
            this.data.translateY
              ? touches[0].clientY - startTouches[0].clientY
              : 0
          )
          .multiply(this.data.startTransformMatrix);
        this.setData({
          transformMatrix: transformMatrix,
        });
      }
    },

    touchEnd: function (e) {},
  },
});

```

```js
// dommatrix.js
"use strict";
var Z = Object.defineProperty;
var z = (s, t, e) =>
  t in s
    ? Z(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e })
    : (s[t] = e);
var p = (s, t, e) => (z(s, typeof t != "symbol" ? t + "" : t, e), e);
const $ = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0,
    m11: 1,
    m12: 0,
    m13: 0,
    m14: 0,
    m21: 0,
    m22: 1,
    m23: 0,
    m24: 0,
    m31: 0,
    m32: 0,
    m33: 1,
    m34: 0,
    m41: 0,
    m42: 0,
    m43: 0,
    m44: 1,
    is2D: !0,
    isIdentity: !0,
  },
  E = (s) =>
    (s instanceof Float64Array ||
      s instanceof Float32Array ||
      (Array.isArray(s) && s.every((t) => typeof t == "number"))) &&
    [6, 16].some((t) => s.length === t),
  P = (s) =>
    s instanceof DOMMatrix ||
    s instanceof y ||
    (typeof s == "object" && Object.keys($).every((t) => s && t in s)),
  g = (s) => {
    const t = new y(),
      e = Array.from(s);
    if (!E(e))
      throw TypeError(
        `CSSMatrix: "${e.join(",")}" must be an array with 6/16 numbers.`
      );
    if (e.length === 16) {
      const [n, i, r, a, l, m, h, c, u, f, w, o, d, A, M, b] = e;
      (t.m11 = n),
        (t.a = n),
        (t.m21 = l),
        (t.c = l),
        (t.m31 = u),
        (t.m41 = d),
        (t.e = d),
        (t.m12 = i),
        (t.b = i),
        (t.m22 = m),
        (t.d = m),
        (t.m32 = f),
        (t.m42 = A),
        (t.f = A),
        (t.m13 = r),
        (t.m23 = h),
        (t.m33 = w),
        (t.m43 = M),
        (t.m14 = a),
        (t.m24 = c),
        (t.m34 = o),
        (t.m44 = b);
    } else if (e.length === 6) {
      const [n, i, r, a, l, m] = e;
      (t.m11 = n),
        (t.a = n),
        (t.m12 = i),
        (t.b = i),
        (t.m21 = r),
        (t.c = r),
        (t.m22 = a),
        (t.d = a),
        (t.m41 = l),
        (t.e = l),
        (t.m42 = m),
        (t.f = m);
    }
    return t;
  },
  X = (s) => {
    if (P(s))
      return g([
        s.m11,
        s.m12,
        s.m13,
        s.m14,
        s.m21,
        s.m22,
        s.m23,
        s.m24,
        s.m31,
        s.m32,
        s.m33,
        s.m34,
        s.m41,
        s.m42,
        s.m43,
        s.m44,
      ]);
    throw TypeError(
      `CSSMatrix: "${JSON.stringify(
        s
      )}" is not a DOMMatrix / CSSMatrix / JSON compatible object.`
    );
  },
  O = (s) => {
    if (typeof s != "string")
      throw TypeError(`CSSMatrix: "${JSON.stringify(s)}" is not a string.`);
    const t = String(s).replace(/\s/g, "");
    let e = new y();
    const n = `CSSMatrix: invalid transform string "${s}"`;
    return (
      t
        .split(")")
        .filter((i) => i)
        .forEach((i) => {
          const [r, a] = i.split("(");
          if (!a) throw TypeError(n);
          const l = a
              .split(",")
              .map((o) =>
                o.includes("rad")
                  ? parseFloat(o) * (180 / Math.PI)
                  : parseFloat(o)
              ),
            [m, h, c, u] = l,
            f = [m, h, c],
            w = [m, h, c, u];
          if (r === "perspective" && m && [h, c].every((o) => o === void 0))
            e.m34 = -1 / m;
          else if (
            r.includes("matrix") &&
            [6, 16].includes(l.length) &&
            l.every((o) => !Number.isNaN(+o))
          ) {
            const o = l.map((d) => (Math.abs(d) < 1e-6 ? 0 : d));
            e = e.multiply(g(o));
          } else if (r === "translate3d" && f.every((o) => !Number.isNaN(+o)))
            e = e.translate(m, h, c);
          else if (r === "translate" && m && c === void 0)
            e = e.translate(m, h || 0, 0);
          else if (r === "rotate3d" && w.every((o) => !Number.isNaN(+o)) && u)
            e = e.rotateAxisAngle(m, h, c, u);
          else if (r === "rotate" && m && [h, c].every((o) => o === void 0))
            e = e.rotate(0, 0, m);
          else if (
            r === "scale3d" &&
            f.every((o) => !Number.isNaN(+o)) &&
            f.some((o) => o !== 1)
          )
            e = e.scale(m, h, c);
          else if (
            r === "scale" &&
            !Number.isNaN(m) &&
            m !== 1 &&
            c === void 0
          ) {
            const d = Number.isNaN(+h) ? m : h;
            e = e.scale(m, d, 1);
          } else if (
            r === "skew" &&
            (m || (!Number.isNaN(m) && h)) &&
            c === void 0
          )
            e = e.skew(m, h || 0);
          else if (
            ["translate", "rotate", "scale", "skew"].some((o) =>
              r.includes(o)
            ) &&
            /[XYZ]/.test(r) &&
            m &&
            [h, c].every((o) => o === void 0)
          )
            if (r === "skewX" || r === "skewY") e = e[r](m);
            else {
              const o = r.replace(/[XYZ]/, ""),
                d = r.replace(o, ""),
                A = ["X", "Y", "Z"].indexOf(d),
                M = o === "scale" ? 1 : 0,
                b = [A === 0 ? m : M, A === 1 ? m : M, A === 2 ? m : M];
              e = e[o](...b);
            }
          else throw TypeError(n);
        }),
      e
    );
  },
  x = (s, t) =>
    t
      ? [s.a, s.b, s.c, s.d, s.e, s.f]
      : [
          s.m11,
          s.m12,
          s.m13,
          s.m14,
          s.m21,
          s.m22,
          s.m23,
          s.m24,
          s.m31,
          s.m32,
          s.m33,
          s.m34,
          s.m41,
          s.m42,
          s.m43,
          s.m44,
        ],
  Y = (s, t, e) => {
    const n = new y();
    return (n.m41 = s), (n.e = s), (n.m42 = t), (n.f = t), (n.m43 = e), n;
  },
  F = (s, t, e) => {
    const n = new y(),
      i = Math.PI / 180,
      r = s * i,
      a = t * i,
      l = e * i,
      m = Math.cos(r),
      h = -Math.sin(r),
      c = Math.cos(a),
      u = -Math.sin(a),
      f = Math.cos(l),
      w = -Math.sin(l),
      o = c * f,
      d = -c * w;
    (n.m11 = o), (n.a = o), (n.m12 = d), (n.b = d), (n.m13 = u);
    const A = h * u * f + m * w;
    (n.m21 = A), (n.c = A);
    const M = m * f - h * u * w;
    return (
      (n.m22 = M),
      (n.d = M),
      (n.m23 = -h * c),
      (n.m31 = h * w - m * u * f),
      (n.m32 = h * f + m * u * w),
      (n.m33 = m * c),
      n
    );
  },
  T = (s, t, e, n) => {
    const i = new y(),
      r = Math.sqrt(s * s + t * t + e * e);
    if (r === 0) return i;
    const a = s / r,
      l = t / r,
      m = e / r,
      h = n * (Math.PI / 360),
      c = Math.sin(h),
      u = Math.cos(h),
      f = c * c,
      w = a * a,
      o = l * l,
      d = m * m,
      A = 1 - 2 * (o + d) * f;
    (i.m11 = A), (i.a = A);
    const M = 2 * (a * l * f + m * c * u);
    (i.m12 = M), (i.b = M), (i.m13 = 2 * (a * m * f - l * c * u));
    const b = 2 * (l * a * f - m * c * u);
    (i.m21 = b), (i.c = b);
    const k = 1 - 2 * (d + w) * f;
    return (
      (i.m22 = k),
      (i.d = k),
      (i.m23 = 2 * (l * m * f + a * c * u)),
      (i.m31 = 2 * (m * a * f + l * c * u)),
      (i.m32 = 2 * (m * l * f - a * c * u)),
      (i.m33 = 1 - 2 * (w + o) * f),
      i
    );
  },
  I = (s, t, e) => {
    const n = new y();
    return (n.m11 = s), (n.a = s), (n.m22 = t), (n.d = t), (n.m33 = e), n;
  },
  v = (s, t) => {
    const e = new y();
    if (s) {
      const n = (s * Math.PI) / 180,
        i = Math.tan(n);
      (e.m21 = i), (e.c = i);
    }
    if (t) {
      const n = (t * Math.PI) / 180,
        i = Math.tan(n);
      (e.m12 = i), (e.b = i);
    }
    return e;
  },
  R = (s) => v(s, 0),
  D = (s) => v(0, s),
  N = (s, t) => {
    const e = t.m11 * s.m11 + t.m12 * s.m21 + t.m13 * s.m31 + t.m14 * s.m41,
      n = t.m11 * s.m12 + t.m12 * s.m22 + t.m13 * s.m32 + t.m14 * s.m42,
      i = t.m11 * s.m13 + t.m12 * s.m23 + t.m13 * s.m33 + t.m14 * s.m43,
      r = t.m11 * s.m14 + t.m12 * s.m24 + t.m13 * s.m34 + t.m14 * s.m44,
      a = t.m21 * s.m11 + t.m22 * s.m21 + t.m23 * s.m31 + t.m24 * s.m41,
      l = t.m21 * s.m12 + t.m22 * s.m22 + t.m23 * s.m32 + t.m24 * s.m42,
      m = t.m21 * s.m13 + t.m22 * s.m23 + t.m23 * s.m33 + t.m24 * s.m43,
      h = t.m21 * s.m14 + t.m22 * s.m24 + t.m23 * s.m34 + t.m24 * s.m44,
      c = t.m31 * s.m11 + t.m32 * s.m21 + t.m33 * s.m31 + t.m34 * s.m41,
      u = t.m31 * s.m12 + t.m32 * s.m22 + t.m33 * s.m32 + t.m34 * s.m42,
      f = t.m31 * s.m13 + t.m32 * s.m23 + t.m33 * s.m33 + t.m34 * s.m43,
      w = t.m31 * s.m14 + t.m32 * s.m24 + t.m33 * s.m34 + t.m34 * s.m44,
      o = t.m41 * s.m11 + t.m42 * s.m21 + t.m43 * s.m31 + t.m44 * s.m41,
      d = t.m41 * s.m12 + t.m42 * s.m22 + t.m43 * s.m32 + t.m44 * s.m42,
      A = t.m41 * s.m13 + t.m42 * s.m23 + t.m43 * s.m33 + t.m44 * s.m43,
      M = t.m41 * s.m14 + t.m42 * s.m24 + t.m43 * s.m34 + t.m44 * s.m44;
    return g([e, n, i, r, a, l, m, h, c, u, f, w, o, d, A, M]);
  };
class y {
  constructor(t) {
    return (
      (this.a = 1),
      (this.b = 0),
      (this.c = 0),
      (this.d = 1),
      (this.e = 0),
      (this.f = 0),
      (this.m11 = 1),
      (this.m12 = 0),
      (this.m13 = 0),
      (this.m14 = 0),
      (this.m21 = 0),
      (this.m22 = 1),
      (this.m23 = 0),
      (this.m24 = 0),
      (this.m31 = 0),
      (this.m32 = 0),
      (this.m33 = 1),
      (this.m34 = 0),
      (this.m41 = 0),
      (this.m42 = 0),
      (this.m43 = 0),
      (this.m44 = 1),
      t ? this.setMatrixValue(t) : this
    );
  }
  get isIdentity() {
    return (
      this.m11 === 1 &&
      this.m12 === 0 &&
      this.m13 === 0 &&
      this.m14 === 0 &&
      this.m21 === 0 &&
      this.m22 === 1 &&
      this.m23 === 0 &&
      this.m24 === 0 &&
      this.m31 === 0 &&
      this.m32 === 0 &&
      this.m33 === 1 &&
      this.m34 === 0 &&
      this.m41 === 0 &&
      this.m42 === 0 &&
      this.m43 === 0 &&
      this.m44 === 1
    );
  }
  get is2D() {
    return (
      this.m31 === 0 &&
      this.m32 === 0 &&
      this.m33 === 1 &&
      this.m34 === 0 &&
      this.m43 === 0 &&
      this.m44 === 1
    );
  }
  setMatrixValue(t) {
    return typeof t == "string" && t.length && t !== "none"
      ? O(t)
      : Array.isArray(t) ||
        t instanceof Float64Array ||
        t instanceof Float32Array
      ? g(t)
      : typeof t == "object"
      ? X(t)
      : this;
  }
  toFloat32Array(t) {
    return Float32Array.from(x(this, t));
  }
  toFloat64Array(t) {
    return Float64Array.from(x(this, t));
  }
  toString() {
    const { is2D: t } = this,
      e = this.toFloat64Array(t).join(", ");
    return `${t ? "matrix" : "matrix3d"}(${e})`;
  }
  toJSON() {
    const { is2D: t, isIdentity: e } = this;
    return { ...this, is2D: t, isIdentity: e };
  }
  multiply(t) {
    return N(this, t);
  }
  translate(t, e, n) {
    const i = t;
    let r = e,
      a = n;
    return (
      typeof r > "u" && (r = 0), typeof a > "u" && (a = 0), N(this, Y(i, r, a))
    );
  }
  scale(t, e, n) {
    const i = t;
    let r = e,
      a = n;
    return (
      typeof r > "u" && (r = t), typeof a > "u" && (a = 1), N(this, I(i, r, a))
    );
  }
  rotate(t, e, n) {
    let i = t,
      r = e || 0,
      a = n || 0;
    return (
      typeof t == "number" &&
        typeof e > "u" &&
        typeof n > "u" &&
        ((a = i), (i = 0), (r = 0)),
      N(this, F(i, r, a))
    );
  }
  rotateAxisAngle(t, e, n, i) {
    if ([t, e, n, i].some((r) => Number.isNaN(+r)))
      throw new TypeError("CSSMatrix: expecting 4 values");
    return N(this, T(t, e, n, i));
  }
  skewX(t) {
    return N(this, R(t));
  }
  skewY(t) {
    return N(this, D(t));
  }
  skew(t, e) {
    return N(this, v(t, e));
  }
  transformPoint(t) {
    const e = this.m11 * t.x + this.m21 * t.y + this.m31 * t.z + this.m41 * t.w,
      n = this.m12 * t.x + this.m22 * t.y + this.m32 * t.z + this.m42 * t.w,
      i = this.m13 * t.x + this.m23 * t.y + this.m33 * t.z + this.m43 * t.w,
      r = this.m14 * t.x + this.m24 * t.y + this.m34 * t.z + this.m44 * t.w;
    return t instanceof DOMPoint
      ? new DOMPoint(e, n, i, r)
      : { x: e, y: n, z: i, w: r };
  }
}
p(y, "Translate", Y),
  p(y, "Rotate", F),
  p(y, "RotateAxisAngle", T),
  p(y, "Scale", I),
  p(y, "SkewX", R),
  p(y, "SkewY", D),
  p(y, "Skew", v),
  p(y, "Multiply", N),
  p(y, "fromArray", g),
  p(y, "fromMatrix", X),
  p(y, "fromString", O),
  p(y, "toArray", x),
  p(y, "isCompatibleArray", E),
  p(y, "isCompatibleObject", P);
module.exports = y;
//# sourceMappingURL=dommatrix.cjs.map
```


 使用

 ```html
  <gesture-view
    width="100vw"
    height="100vh"
    translateYValue="{{translateYValue}}"
    scaleMin="{{0.6}}"
    rotate="{{false}}"
  >
  text
  </gesture-view>
 ```


### 动画效果

```html
<view
  animation="{{animationData}}"
>
somethings
</view>
<button bind:tap="switch">
  切换
</button>
```


```js
data:{
  animation: null,
  animationDuration: 300,
},

onLoad() {
  this.data.animation = wx.createAnimation({
    duration: this.data.animationDuration,
  });
},

switch(){
   this.data.animation.scale(0.96).opacity(0.6).step();
    this.setData({
      animationData: this.data.animation.export(),
    });
    setTimeout(() => {
      this.data.animation.scale(1).opacity(1).step();
      this.setData({
        animationData: this.data.animation.export(),
      });
    }, this.data.animationDuration);
}
```

### 微信小程序各种分享逻辑

#### 小程序原生页面内分享（open-type="share）

```html
<button class="active-share-button" open-type="share">
     <view class="share-action-text">分享</view>
</button>
```

```js
Page({
  onShareAppMessage() {
    const promise = new Promise(resolve => {
      setTimeout(() => {
        resolve({
          userName: '小程序原始id',  
          path: 'pages/index/index',
          title: '标题',
          imagePath: '/pages/thumb.png',
          webpageUrl: 'www.qq.com',
          withShareTicket: true,
          miniprogramType: 0,
          scene: 0, 
        })
      }, 2000)
    })
    return {
      userName: '小程序原始id',  
      path: 'pages/index/index',
      title: '标题',
      imagePath: '/pages/thumb.png',
      webpageUrl: 'www.qq.com',
      withShareTicket: true,
      miniprogramType: 0,
      scene: 0, 
      promise 
    }
  }
})
```


> 此分享按钮点击后，可以直接调用起微信官方的分享弹窗，不需用通过点击右上角的三个点来进行分享


#### 微信小程序原生页面调用分享和下载弹窗


```html
wx.showShareImageMenu({
      path: this.data.domCanvasUrl,
});
```

> 打开分享图片弹窗，可以将图片发送给朋友、收藏或下载


#### 微信小程序webview页面分享（jssdk）


文档：[点击查看](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#2)

1. 引入jssdk

在需要调用JS接口的页面引入如下JS文件：http://res.wx.qq.com/open/js/jweixin-1.6.0.js （支持https）


2. 配置config

```js
// 通过后端接口获取wx.config需要的参数
wx.config({
  debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。
  appId: '', // 必填，公众号的唯一标识
  timestamp: , // 必填，生成签名的时间戳
  nonceStr: '', // 必填，生成签名的随机串
  signature: '',// 必填，签名
  jsApiList: [] // 必填，需要使用的JS接口列表
});
wx.ready(function () {   //需在用户可能点击分享按钮前就先调用
  wx.updateAppMessageShareData({ 
    title: '', // 分享标题
    desc: '', // 分享描述
    link: '', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致
    imgUrl: '', // 分享图标
    success: function () {
      // 设置成功
    }
  })
});
```


> 此行为只能设置webview中的分享内容，如：标题、文案、图片等，但是无法直接唤起微信分享弹窗，需要用户手动点击右上角三个点来进行分享，所以一般需要一个提示蒙层来提醒用户点击右上角的三个点来分享


### 微信小程序原生页面跳转其他小程序

```js
wx.navigateToMiniProgram({
  appId: '1111',
  path: 'page/index/index?id=123',
  extraData: {
    foo: 'bar'
  },
  envVersion: 'develop',
  success(res) {
    // 打开成功
  }
})
```


#### 微信小程序webview页面内唤起其他小程序(开放标签)

文档：[点击查看](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html#21)


跳转小程序：wx-open-launch-weapp
用于页面中提供一个可跳转指定小程序的按钮。使用此标签后，用户需在网页内点击标签按钮方可跳转小程序。H5通过开放标签打开小程序的场景值为1167。

使用步骤

1. 引入jssdk

在需要调用JS接口的页面引入如下JS文件：http://res.wx.qq.com/open/js/jweixin-1.6.0.js （支持https）

2. 配置config

```js
wx.config({
  debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印
  appId: '', // 必填，公众号的唯一标识
  timestamp: , // 必填，生成签名的时间戳
  nonceStr: '', // 必填，生成签名的随机串
  signature: '',// 必填，签名
  jsApiList: [], // 必填，需要使用的JS接口列表
  openTagList: [] // 可选，需要使用的开放标签列表，例如['wx-open-launch-app']
});
```

3. 在dom结构中添加wx-open-launch-weapp标签

```html
<wx-open-launch-weapp
  id="launch-btn"
  appid="wx12345678"
  path="pages/home/index?user=123&action=abc"
>
  <script type="text/wxtag-template">
    <style>.btn { padding: 12px }</style>
    <button class="btn">打开小程序</button>
  </script>
</wx-open-launch-weapp>
<script>
  var btn = document.getElementById('launch-btn');
  btn.addEventListener('launch', function (e) {
    console.log('success');
  });
  btn.addEventListener('error', function (e) {
    console.log('fail', e.detail);
  });
</script>
```

> 点击页面中的分享按钮后，会自动唤起跳转目标小程序的弹窗


### 动画帧实现图片大小跟随scroll-view滚动而变化

[查看文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/animation.html)

```html
<scroll-view
  scroll-y="{{true}}"
  enhanced="{{true}}"
  bounces="{{false}}"
  class="main-appreciate-content-container"
  id="scroller"
>
    <image
      id="collection_image"
      class="full-screen-image"
      mode="aspectFit"
      src="{{collectionInfo.cover_img}}"
    />
</scroll-view>
```


```js
  onReady() {
    this._animate();
  },

  _animate() {
    console.log("执行");
    wx.createSelectorQuery()
      .select("#scroller")
      .fields(
        {
          scrollOffset: true,
          size: true,
        },
        (res) => {
          console.log("res: ", res);
          this.animate(
            "#collection_image",
            [
              {
                transform: "scale(1) translateY(0)",
              },
              {
                transform: `scale(.6) translateY(-88%)`,
              },
            ],
            2000,
            {
              scrollSource: "#scroller",
              timeRange: 4000,
              startScrollOffset: 0,
              endScrollOffset: 1200,
            }
          );
        }
      )
      .exec();
  },
```


> 随着scroll-view的上下滑动，内部的collection_image图片也会根据关键帧自动进行缩放和平移


### 发起请求api封装

```js
// 记录失败请求最大次数的map
let maxRequestNumberMap = new Map();

export const request = async (url, options = {}) => {
  //console.log("options: ", options);
  if (url == "") {
    console.log("请求地址必传....");
    return;
  }

  const token = wx.getStorageSync("token");
  const wxRequestPromise = new Promise((resolve, reject) => {
    wx.request({
      url: httpApi + "/" + url,
      method: options.method || "POST",
      data: options.data || {},
      header: {
        Authorization: token ? "Bearer " + token : "",
        version: "0.0.0",
      },
      success: (res) => {
        resolve(res.data);
      },
      fail: (err) => {
        reject({ err: 1, msg: "执行失败", data: err });
      },
    });
  });

  const result = await wxRequestPromise;
  let responseData = {}; // 最终请求接口返回的数据
  if (isRequestSuccess(result.code)) {
    if (options?.resolve === "full") {
      Object.assign(responseData, { err: 0, msg: "执行成功", data: result });
      console.log("result: ", result);
    } else {
      Object.assign(responseData, {
        err: 0,
        msg: "执行成功",
        data: result.data,
      });
    }
    return responseData;
  } else {
    // 记录当前接口的返回token不正确的次数，超过3次，我们认为是进入了死循环，终止再次请求
    if (
      result.code == '40101' &&
      (maxRequestNumberMap.get(url) < 3 ||
        maxRequestNumberMap.get(url) == undefined)
    ) {
      if (maxRequestNumberMap.get(url) === undefined) {
        maxRequestNumberMap.set(url, 1);
      } else {
        let oldNumber = maxRequestNumberMap.get(url);
        maxRequestNumberMap.set(url, oldNumber + 1);
      }
      // 未登录或者token过期，需要先更新token，再重新发起请求，并合并数据
      const appInstance = getApp();
      await updateUserInfoByWXLogin(appInstance);
      const innerRequest = await request(url, options);
      if (options?.resolve === "full") {
        Object.assign(responseData, {
          err: 0,
          msg: "执行成功",
          data: innerRequest,
        });
      } else {
        Object.assign(responseData, {
          err: 0,
          msg: "执行成功",
          data: innerRequest.data,
        });
      }
      return responseData;
    } else {
      if (result.msg) {
       wx.showToast({
         title: result.msg,
         icon: 'error',
         duration: 2000
       })
      return Promise.reject({ result });
    }
  }
};

function isRequestSuccess(code) {
  let pass =
    code == '20001' || code == '20101' || code == '20401';
  return pass;
}

export function updateUserInfoByWXLogin(app) {
  return new Promise((resolve, reject) => {
    // 通过wx.login获取微信code
    // 使用该code去后端换取用户信息、openId、unionId等
    wx.login({
      success: (res) => {
        let url = "index/login";
        let options = { code: res.code };
        wx.request({
          url: httpApi + "/" + url,
          method: options.method || "POST",
          data: options || {},
          header: {},
          success: (res) => {
            const result = res.data;
            console.log("result: ---------", result);
            const { user } = result.data;
            wx.setStorageSync("userInfo", user);
            wx.setStorageSync("openId", user.wx_user.openid);
            wx.setStorageSync("unionId", user.wx_user.unionid);
            wx.setStorageSync("token", result.data.token);
            wx.setStorageSync("shopToken", result.data.shop_token);

            //console.log(app, "获取小程序主体");
            app.globalData.token = result.data.token;
            resolve({ token: result.data.token });
          },
        });
      },
    });
  });
}

```


---
title: 微信小程序使用
date: 2022-09-15 11:27:37
tags: [微信小程序]
---

## 微信小程序使用

<!-- more -->

### 微信小程序内嵌 H5

#### 客户方操作

1. 登录：https://mp.weixin.qq.com/
2. 左侧菜单栏：开发管理>> 开发设置
3. 找到业务域名，点击开始配置
4. 下载校验文件
5. 等待第三方上传校验文件
6. 继续校验文件验证流程

#### 第三方操作

1. 将客户提供的校验文件上传到服务器根目录
2. 通知客户已经上传校验文件，并让客户验证

### 微信 ab 转 base64

```js
import { filetypemime } from "magic-bytes.js";

export function generateDataUrl(ab, mime) {
  if (!mime) {
    const mimeList = filetypemime(new Uint8Array(ab, 0, 100));
    if (mimeList?.length) {
      mime = mimeList[0];
    } else {
      throw new TypeError("无法检测出文件MIME类型");
    }
  } else if (!mime.includes("/")) {
    throw new TypeError("请输入正确的MIME格式");
  }

  return `data:${mime};base64,${wx.arrayBufferToBase64(ab)}`;
}

generateDataUrl(ab);
```

### 小程序本身封装的组件

1. picker（从底部弹起的滚动选择器）

   ```js
   <picker
     bindchange="bindPickerChange"
     value="{{selectList[index].name}}"
     range="{{selectList}}"
     range-key="{{'name'}}"
   >
     <view class="picker">{{ currentType }}</view>
   </picker>
   ```

   外层用 picker 包裹，内部通过 range 设定滚动数据，range-key 做渲染关键词，最后获得的是 value 的值。

   bindPickerChange 方法做赋值的操作（略。。。）

2. scroll-view（可滚动视图区域)

   ```js
   <scroll-view scroll-x="true" class="nav" scroll-left="{{navScrollLeft}}" scroll-with-animation="{{true}}">
   			<block wx:for="{{classifyList}}" wx:for-index="idx" wx:for-item="item" wx:key="idx">
   				<view class="nav-item {{currentTab == idx ?'active':''}} flex_center_center" data-current="{{idx}}" data-id='{{item.classify_id}}' data-int='{{idx}}' data-name="{{item.name}}" bindtap="switchNav">
   					<text class="t_name">{{item.name}}</text>
   				</view>
   			</block>
   </scroll-view>
   ```

   scroll-left:设置横向滚动条位置

   scroll-with-animation:在设置滚动条位置时使用动画过渡

3. swiper (滑块视图容器)

   ```js
   <swiper
     class="swipers"
     autoplay="{{false}}"
     duration="0"
     current="{{currentTab}}"
     bindchange="swiperChange"
   >
     <block
       wx:for="{{classifyList}}"
       wx:for-index="idxs"
       data-index="{{idxs}}"
       wx:for-item="item"
       wx:key="idx"
     >
       <swiper-item catchtouchmove="stopTouchMove"></swiper-item>
     </block>
   </swiper>
   ```

   autoplay:是否自动切换(轮播图的形式)

   duration:滑动动画时长

   current：当前所在滑块的 index

   catchtouchmove：禁止用户手动滑动页面

4. cover-view（覆盖在原生组件之上的文本视图）cover-image（覆盖在原生组件之上的图片视图）

   ```js
   <cover-view hidden="{{!hidePause}}" catchtap="pauseVideo" class="pause-video"></cover-view>
   <cover-image hidden="{{hidePause}}" catchtap="replayVideo" src="/assets/pause@2x.png" class="play-video"></cover-image>
   <cover-view style="padding-top:{{navTop}}px;height:{{navHeight}}px" class="nav">
   	<cover-image catchtap="gotoPrev" src="/assets/ic_cancel_white@2x.png" class="back-icon"></cover-image>
   </cover-view>
   ```

### 手动封装的组件

1. AlertBox(页面中间出现的弹框，中间为文字提示，拥有取消和确定按钮)

   ```js
   //父页面中使用
   <AlertBox
     bind:getUserConfirmResult="getUserConfirmResult"
     alert_title="{{alert_title}}"
     is_show="{{is_show}}"
   ></AlertBox>
   ```

   ```js
   //子页面的结构
    <!--弹框-->
     <view wx:if="{{is_show}}" class="alert_box">
       <view class="clearfloat">
         <view bindtap="closeButton" class="alert_close">
           <image src="../../assets/close@2x.png" mode="widthFix"></image>
         </view>
       </view>

       <view class="alert_title">{{alert_title}}</view>
       <view class="alert_button">
         <button class="confirm_button" bindtap="confirmButton">确定</button>
       </view>
     </view>
   ```

   涉及到父子组件传值的说明：

   父组件中：bind:getUserConfirmResult = "getUserConfirmResult"相当于自定义事件。可以从子组件获取到用户对于取消和确定的值，从而选择不同的显示效果。

   ```js
   //父组件调用自定义方法
   getUserConfirmResult(e) {
       //console.info("e", e)
       let that = this;
       that.setData({
         is_show: false
       });
     },
   ```

   ```js
   //子组件中调用的方法。通过this.triggerEvent()通知到父组件的自定义事件。类似于 vue 中 this.$emit。
   confirmButton:function(){
         console.info("1111111")
         let that = this;

         let myEventDetail = {
           is_show:false,
         };
         let myEventOption = {bubbles:false};
         that.triggerEvent('getUserConfirmResult', myEventDetail, myEventOption)
       },
   ```

   自定义组件触发事件时，需要使用 `triggerEvent` 方法，指定事件名、detail 对象和事件选项：

   选项：bubbles ： 事件是否冒泡；composed：事件是否可以穿越组件边界；capturePhase： 事件是否拥有捕获阶段

### 使用彩色的图标 1

```js
配合阿里iconfont，下载icon项目，进入iconfont文件夹
npm install -g iconfont-tools
iconfont-tools
在原来下载的目录中多出来一个文件夹
打开文件夹选择其中的wxss文件引入到微信小程序中即可
```

使用如下：

```js
<icon class="t-icon t-icon-ziyuan9"></icon>;
icon - ziyuan9就是iconfont中复制的class;
```

### 使用彩色的图标 2

阿里 iconfont 提供了 Symbol 类型的引入方式，拥有很多优点，记录下再小程序中的使用

```js
npm install mini-program-iconfont-cli --save-dev

npx iconfont-init
# 可传入配置输出路径
# npx iconfont-init --output iconfont.json
```

初始化后会生成一个 json 配置文件,修改配置如下

```js
{
  "symbol_url": "//at.alicdn.com/t/font_2428200_oocwz3ghukn.js",
  "save_dir": "miniprogram/components/iconfont",
  "use_rpx": true,
  "trim_icon_prefix": "icon",
  "default_icon_size": 50
}
```

symbol_url：将官网的地址引入

save_dir：根据自己的目录生成

生成标准组件

```js
# 可传入配置文件路径
# npx iconfont-XXXX --config iconfont.json

# 微信小程序
npx iconfont-wechat

# 支付宝小程序
npx iconfont-alipay

# 百度小程序
npx iconfont-baidu

# 头条小程序
npx iconfont-toutiao

# QQ小程序
npx iconfont-qq
```

引入

在根目录 的 app.json 文件中引入全局图标组件，避免每个 page 都引入，也可单个 page 引入

```
// 绝对路径
{
    "usingComponents": {
      "iconfont": "components/iconfont/iconfont"
    }
}
```

使用组件

```js
// 原色彩
<iconfont name="alipay" />

// 单色：红色
<iconfont name="alipay" color="red" />

// 多色：红色+橘色
<iconfont name="alipay" color="{{['red', 'orange']}}" size="300" />

// 不同格式的颜色写法
<iconfont name="alipay" color="{{['#333', 'rgb(50, 124, 39)']}}" />
```

### 微信浏览器打开 h5，然后跳转小程序

```vue
<template>
  <div class="mp-btn-mask">
    <wx-open-launch-weapp
      id="launch-btn"
      ref="btnBox"
      class="launch-mp-btn"
      :appid="mpConfig.appid"
      :path="mpConfig.path"
      @ready="ready"
      @launch="launch"
      @error="error"
      style="display: block"
    >
      <script type="text/wxtag-template">
        <style>
          .btn {
            display: block;
            width: 220px;
            height: 45px;
            line-height: 45px;
            text-align: center;
            background: #51afaf;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 400;
            color: #fff;
            letter-spacing: 3px;
            padding: 0;
          }
        </style>
        <div class="btn">前往展示</div>
      </script>
    </wx-open-launch-weapp>
    <!-- <div class="mask-btn" >{{ text }}</div> -->
  </div>
</template>

<script>
import Vue from "vue";
// 忽略自定义元素标签抛出的报错
Vue.config.ignoredElements = ["wx-open-launch-weapp"];
export default {
  name: "BuyBtn",
  props: {
    mpConfig: {
      type: Object,
      default: function () {
        return {
          appid: "wxc9a643121000b22b",
          path: "pages/product-list/product-list.html?categoryId=46",
        };
      },
    },
  },
  data() {
    return {
      text: "...",
    };
  },
  methods: {
    ready(e) {
      console.log("ready", e);
      this.text = "前往展示";
      document.getElementById("launch-btn").click();
      console.log("click after", document.getElementById("launch-btn"));
      // console.log(
      //   'document.getElementById("innerBtn")',
      //   document.getElementById("launch-btn").children
      // );
    },
    launch(e) {
      console.log("launch", e);
    },
    error(e) {
      console.log("error", e);
    },
  },
};
</script>

<style lang="scss" scoped>
// .mp-btn-mask {
//   // width:60vw;
//   height: 12vw;
//   position: relative;
//   overflow: hidden;
//   .mask-btn {
//     position: absolute;
//     left: 0;
//     top: 0;
//     width: 60vw;
//     height: 12vw;
//     background: #51afaf;
//     border-radius: 2.13vw;
//     font-size: 4vw;
//     font-weight: 400;
//     color: #ffffff;
//     letter-spacing: 3px;
//     padding: 0;
//     display: flex;
//     justify-content: center;
//     align-items: center;
//     pointer-events: none;
//   }
// }
.launch-mp-btn {
  width: 220px;
  height: 45px;
  // background: #51afaf;
  // border-radius: 2.13vw;
  // font-size: 3.73vw;
  // font-weight: 400;
  // color: #ffffff;
  // letter-spacing: 3px;
  // padding: 0;
  // display: flex;
  // justify-content: center;
  // align-items: center;
}
</style>
```

微信 config 配置

```js
wx.config({
  ...res.data,
  debug: false,
  jsApiList: [
    "onMenuShareTimeline",
    "onMenuShareAppMessage",
    "onMenuShareQQ",
    "onMenuShareWeibo",
    "onMenuShareQZone",
    "chooseImage",
  ],
  openTagList: ["wx-open-launch-weapp"],
});
```

#### 注意事项

```js
<script type="text/wxtag-template"></script>
//  script中不能使用vw单位，否则会看不到按钮
```

### 微信通过渠道参数来访问 webview

```js
  onLoad(options) {
    console.log(options, "----");
    const { url } = options;
    // let url =
    //   "https%3A%2F%2Fmeta.kivisense.com%2Fcanada-goose-slt%2Findex.html%3F_um_campaign%3D64eddfe78efadc41dccf05a0%26_um_channel%3D64eddfe78efadc41dccf05a1";
    if (url) {
      let finalUrl = decodeURIComponent(url);
      console.log("finalUrl: ", finalUrl);
      let right = finalUrl.includes("https://");
      console.log("right: ", right);
      if (right) {
        this.setData({
          src: finalUrl,
        });
      }
    }
  },
```

### 正确使用权限

```js
  chosePhoto() {
    wx.getStorage({
      key: "is_check_privacy",
      success: () => {
        wx.showActionSheet({
          itemList: ["拍照", "从相册中选择"],
          success: (res) => {
            console.log(res.tapIndex);
            if (res.tapIndex === 0) {
              console.log("拍照");
              wx.getSetting({
                success: (res) => {
                  if (res.authSetting["scope.camera"]) {
                    // 用户已经授权
                    console.log("用户已经授权: ");
                    this.setData({
                      isCameraOpen: true,
                      trigger: "parent",
                    });
                  } else {
                    // 用户还没有授权，向用户发起授权请求
                    console.log("用户还没有授权，向用户发起授权请求: ");
                    wx.authorizeForMiniProgram({
                      scope: "scope.camera",
                      success: () => {
                        // 用户同意授权
                        // 打开相机组件
                        this.setData({
                          isCameraOpen: true,
                          trigger: "parent",
                        });
                      },
                      fail: () => {
                        // 用户不同意授权
                        showAuthModal("scope.camera", {
                          content: "需要使用“摄像头”权限",
                        });
                      },
                    });
                  }
                },
                fail: (res) => {
                  console.log("获取用户授权信息失败", res);
                  wx.showToast({
                    title: "获取用户授权信息失败",
                    icon: "none",
                    duration: 3000,
                  });
                },
              });
              stats("AIPaintingUploadPhotos_click_takePhoto");
            }
            if (res.tapIndex === 1) {
              this.setData({
                showModal: true,
              });
              stats("AIPaintingUploadPhotos_click_localAlbum");
            }
          },
          fail(res) {
            console.log(res.errMsg);
          },
        });
        stats("AIPaintingUploadPhotos_click_photo");
      },
      fail: () => {
        this.setData({
          showPrivacyModal: true,
          isCheckPrivacy: false,
        });
      },
    });
  },
```

弹起授权弹窗

```js
export async function showAuthModal(scope, config = { content: "" }) {
  try {
    const defaultConfig = {
      title: "提示",
      confirmText: "立即授权",
      confirmColor: "#02BB00",
    };

    const { confirm, cancel } = await promisify(wx.showModal)({
      ...defaultConfig,
      ...config,
    });
    if (confirm) {
      const {
        authSetting: { [scope]: isAuth },
      } = await promisify(wx.openSetting)();
      if (!isAuth) {
        return await showAuthModal(scope, config);
      }
      return true;
    } else if (cancel) {
      return false;
    } else {
      throw new Error("未知问题");
    }
  } catch (e) {
    console.error(e);
    return false;
  }
}

export function promisify(fn, context) {
  return (...config) => {
    return new Promise((resolve, reject) => {
      config[0] = {
        ...config[0],
        success: resolve,
        fail: reject,
      };
      const result = fn.apply(context || wx, config);
      if (config && typeof config.result === "function") {
        config.result(result);
      }
    });
  };
}

export function downloadFile(url, onProgress = () => {}) {
  const progressCallBack = (res) => {
    onProgress({ loaded: res.progress, total: 100 });
  };
  return new Promise((resolve, reject) => {
    const downloadTask = wx.downloadFile({
      url,
      success({ statusCode, tempFilePath }) {
        if (statusCode === 200) {
          resolve(tempFilePath);
        } else {
          reject(new Error(`下载文件(${url})失败, statusCode: ${statusCode}`));
        }
      },
      fail: reject,
      complete: () => {
        downloadTask.offProgressUpdate(progressCallBack);
      },
    });
    downloadTask.onProgressUpdate(progressCallBack);
  });
}

export function requestFile(
  url,
  onProgress = () => {},
  responseType = "arraybuffer"
) {
  return new Promise((resolve, reject) => {
    onProgress({ loaded: 0.2, total: 1 });
    wx.request({
      url,
      responseType,
      success({ statusCode, data }) {
        if (statusCode === 200) {
          onProgress({ loaded: 1, total: 1 });
          resolve(data);
        } else {
          reject(new Error(`下载文件(${url})失败, statusCode: ${statusCode}`));
        }
      },
      fail: reject,
    });
  });
}
```

### 插件使用与调试

#### 本地示例小程序中使用插件

app.json 中的使用区别

```json
{
  "pages": ["pages/index/index"],
  "plugins": {
    "chaumet": {
      "version": "dev",
      "provider": "wx2829a059adc932bd"
    }
  },
  "sitemapLocation": "sitemap.json"
}
```

#### 其他小程序使用开发版插件

```json
{
  "pages": ["pages/index/index"],
  "plugins": {
    "chaumet": {
      "version": "dev-5007f4fc31b382b21d40c1101d1bf5c2",
      "provider": "wx2829a059adc932bd"
    }
  },
  "sitemapLocation": "sitemap.json"
}
```

#### 其他小程序使用正式版插件

```json
{
  "pages": ["pages/index/index"],
  "plugins": {
    "chaumet": {
      "version": "1.0.0",
      "provider": "wx2829a059adc932bd"
    }
  },
  "sitemapLocation": "sitemap.json"
}
```

### 获取一个 node 节点

```js
const res = await new Promise((resolve) => {
  this.createSelectorQuery()
    .select(".canvas")
    .fields({
      node: true,
      size: true,
    })
    .exec((els) => resolve(els[0]));
});
const canvas = res.node;
```


### 使用canvas下载网络图片


```html
<view class="canvas-container">
  <canvas
    type="2d"
    id="offsetCanvas"
    style="width:{{canvasPixelWidth}}px;height:{{canvasPixelHeight}}px"
  />
</view>
```

```css
.canvas-container {
  position: fixed;
  top: -9999px;
  left: -9999px;
  width: 100vw;
  height: 100vh;
}
```

```js
/**
 * @description
 * 组件使用：
 * 当外部传入url不为空字符串时，则会触发saveImageByCanvas从而保存网路图片到相册，
 * 组件会在保存相册成功后，抛出finish事件。
 * -----------
 * 可以通过exportType字段设定导出图片模式：
 * origin模式：按照图片原始比例保存到相册；
 * custom模式：可以指定width和height，保存到相册的图片根据指定宽高来居中裁剪。
 */

Component({
  properties: {
    url: {
      type: String,
      value: "",
    },
    // 组件传递过来的宽高如果大于手机屏幕本身的宽高，
    // 会被等比例缩放至屏幕相近的大小。
    width: {
      type: Number,
      value: wx.getSystemInfoSync().windowWidth,
    },
    height: {
      type: Number,
      value: wx.getSystemInfoSync().windowHeight,
    },
    // origin:根据图片的原始尺寸导出(默认值)
    // custom:根据properties.width和properties.height的值导出
    exportType: {
      type: String,
      value: "origin",
    },
  },

  data: {
    ctx: null,
    canvas: null,

    screenWidth: wx.getSystemInfoSync().windowWidth,
    screenHeight: wx.getSystemInfoSync().windowHeight,

    canvasPixelWidth: wx.getSystemInfoSync().windowWidth,
    canvasPixelHeight: wx.getSystemInfoSync().windowHeight,
  },

  observers: {
    url: function (u) {
      if (u) {
        this.saveImageByCanvas(u);
      }
    },
  },

  methods: {
    async saveImageByCanvas(url) {
      const { path, width, height } = await wx.getImageInfo({
        src: url,
      });

      this.setCanvasSize(width, height);

      const nodeList = await this.getNode("#offsetCanvas");

      this.makeCanvasDisplayBetter(nodeList[0]);

      this.drawImageThenExport(path);
    },

    setCanvasSize(width, height) {
      let w =
        this.properties.exportType === "origin" ? width : this.properties.width;
      let h =
        this.properties.exportType === "origin"
          ? height
          : this.properties.height;

      const { shortW, shortH } = this.calcCanvasSize(w, h);

      this.setData({
        canvasPixelWidth: shortW,
        canvasPixelHeight: shortH,
      });
    },

    calcCanvasSize(w, h) {
      // 如果canvas上的style内联width/height非常大，那么，真机上绘制图片时，可能会白屏
      // https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html
      // 简单测试了下，大概安全宽度和高度是：900*1350，
      // 即：如果canvas的内联样式宽度在900以内，高度在1350以内，真机可以正常渲染
      // 此处为了兼容性，函数会直接将canvas的内联宽高缩放至屏幕大小
      if (w > this.data.screenWidth || h > this.data.screenHeight) {
        let screenRatio = this.data.screenWidth / this.data.screenHeight;
        let selfRatio = w / h;
        if (screenRatio > selfRatio) {
          w = (w * this.data.screenHeight) / h;
          h = this.data.screenHeight;
        } else {
          h = (h * this.data.screenWidth) / w;
          w = this.data.screenWidth;
        }
      }
      return { shortW: w, shortH: h };
    },

    getNode(id) {
      return new Promise((res, rej) => {
        const query = wx.createSelectorQuery().in(this);
        query
          .select(id)
          .fields({ node: true, size: true })
          .exec((e) => {
            if (e[0]) {
              res(e);
            } else {
              rej(e);
            }
          });
      });
    },

    makeCanvasDisplayBetter(nodeInfo) {
      const { node: canvas } = nodeInfo;
      const { pixelRatio } = wx.getSystemInfoSync();
      const ctx = canvas.getContext("2d");
      // 此处将canvas的尺寸扩大（3倍）,缩放扩大（3倍），
      // 并且在style内联样式中又指定canvas的宽（1倍）和高（1倍），来实现更清晰的canvas显示效果。
      // 原理：生成3倍大小canvas，通过css缩放到1倍宽高的dom中显示。
      // 相当于将900*900的图片，展示到一个300*300大小的dom框中，清晰度会提高。
      // 微信小程序会显示canvas的最大尺寸为：4096*4096，超出会报错
      const dpr = this.calcDPR(pixelRatio);
      canvas.width = this.data.canvasPixelWidth * dpr;
      canvas.height = this.data.canvasPixelHeight * dpr;
      ctx.scale(dpr, dpr);
      this.setData({
        canvas,
        ctx,
      });
    },

    calcDPR(pixelRatio) {
      let dpr = pixelRatio;
      if (
        this.data.canvasPixelWidth * pixelRatio > 4096 ||
        this.data.canvasPixelHeight * pixelRatio > 4096
      ) {
        const shortDPR = this.calcDPR(pixelRatio - 1);
        return shortDPR;
      } else {
        return dpr;
      }
    },

    drawImageThenExport(path) {
      let imgObj = this.data.canvas.createImage();
      imgObj.onload = () => {
        if (imgObj.complete) {
          this.drawImage(imgObj);
          this.saveFileToAlbum();
        }
      };
      imgObj.src = path;
    },

    drawImage(imgObj) {
      const { sx, sy, sWidth, sHeight } = this.calcDrawDistance(imgObj);
      this.data.ctx.drawImage(
        imgObj,
        sx,
        sy,
        sWidth,
        sHeight,
        0,
        0,
        this.data.canvasPixelWidth, // 这个值会根据比例自动缩放，所以不需要乘以dpr
        this.data.canvasPixelHeight
      );
    },

    calcDrawDistance(imgObj) {
      let sWidth = 0;
      let sHeight = 0;
      let sx = 0;
      let sy = 0;
      let imageRatio = imgObj.width / imgObj.height;
      let screenRatio =
        this.data.canvasPixelWidth / this.data.canvasPixelHeight;
      if (imageRatio >= screenRatio) {
        sWidth =
          (this.data.canvasPixelWidth * imgObj.height) /
          this.data.canvasPixelHeight;
        sHeight = imgObj.height;
        sx = (imgObj.width - sWidth) / 2;
        sy = 0;
      } else {
        sWidth = imgObj.width;
        sHeight =
          (this.data.canvasPixelHeight * imgObj.width) /
          this.data.canvasPixelWidth;
        sx = 0;
        sy = (imgObj.height - sHeight) / 2;
      }
      return {
        sx,
        sy,
        sWidth,
        sHeight,
      };
    },

    saveFileToAlbum() {
      wx.canvasToTempFilePath({
        x: 0,
        y: 0,
        canvas: this.data.canvas,
        success: (res) => {
          wx.saveImageToPhotosAlbum({
            filePath: res.tempFilePath,
            success: () => {
              this.triggerEvent("finish");
            },
          });
        },
      });
    },
  },
});

```

### 使用canvas生成海报

外部使用
```js
this.generateImageByCanvas("generate");
this.generateImageByCanvas("save");

generateImageByCanvas(action) {
      let updateList = [
        {
          type: "image",
          url: getStaticUrl("qr-code/test_bc.png"),
          dx: 0,
          dy: 0,
          dWidth: this.data.canvasWidth,
          dHeight: this.data.canvasHeight,
          mode: "aspectFill",
        },
        {
          type: "image",
          url: this.properties.currentCollectCardDetail.url,
          dy: 73,
          dWidth: 175.2,
          dHeight: 204,
          mode: "screenCenter",
          borderRadius: 10,
          borderColor: "#E0C069",
          objectFit: "aspectFill",
        },
        {
          type: "text",
          content: this.properties.currentCollectCardDetail.name,
          dy: 300,
          font: "16px",
          fillStyle: "#897160",
          mode: "screenCenter",
          letterSpacing: 1,
        },
        {
          type: "multilineText",
          content: this.properties.currentCollectCardDetail.description,
          dx: 44,
          dy: 320,
          font: "12px",
          fillStyle: "#C2A272",
          line: 4,
          lineHeight: 18,
          maxWidth: 245,
          letterSpacing: 0.5,
        },
        {
          type: "image",
          url: getStaticUrl("qr-code/mini_code_circle.png"),
          dy: 400,
          dWidth: 70,
          dHeight: 70,
          mode: "screenCenter",
        },
        {
          type: "text",
          content: "扫码开启 奇幻之旅",
          dy: 484,
          font: "11px",
          fillStyle: "#897160",
          letterSpacing: 1,
          mode: "screenCenter",
        },
      ];
      this.setData({
        saveDomOptions: updateList,
        action: action,
      });
    },
```

```js
/**
 * @description
 * 组件使用：
 * 组件会在保存相册成功后，抛出finish事件。
 * -----------
 * options的配置项：
 *   type: "multilineText/text/image", // 绘制类型，支持字符和图片
 *   url:'', // 图片地址
 *   content: '', // 文字内容
 *   dx: 44, // 距离左边距
 *   dy: 300, // 距离上边距
 *   dWidth: 200, // 绘制的图片宽度
 *   dHeight: 200, // 绘制的图片高度
 *   font: "12px", // 字体大小
 *   fillStyle: "#C2A272", //字体颜色
 *   textAlign:'', // 字体位置
 *   textBaseline:"", // 字体基线
 *   line: 4, // 多行文字行数
 *   lineHeight:20, // 多行文字行高
 *   maxWidth: 245, // 文字绘制的最大宽度
 *   letterSpacing: 0.5, // 文字间距
 *   mode: "screenCenter", // screenCenter：文字屏幕居中
 *   objectFit:'aspectFill', // aspectFill：图片适配裁剪模式；
 *   borderRadius: 10, // 圆角
 *   borderColor: "#E0C069", // 边框颜色
 */

Component({
  properties: {
    options: {
      type: Array,
      value: () => {},
    },
    // show: {
    //   type: Boolean,
    //   value: false,
    // },
    width: {
      type: Number,
      value: wx.getSystemInfoSync().windowWidth,
    },
    height: {
      type: Number,
      value: wx.getSystemInfoSync().windowHeight,
    },
    action: {
      type: String,
      value: "save",
    },
  },

  data: {
    show: true,
    ctx: null,
    canvas: null,

    // 手机屏幕本身的宽和高
    screenWidth: wx.getSystemInfoSync().windowWidth,
    screenHeight: wx.getSystemInfoSync().windowHeight,

    // 用户通过properties.width和height定义的width和height
    canvasPixelWidth: wx.getSystemInfoSync().windowWidth,
    canvasPixelHeight: wx.getSystemInfoSync().windowHeight,

    pixelRatio: wx.getSystemInfoSync().pixelRatio,
  },

  observers: {
    options: function (n) {
      console.log("n: ", n);
      if (n.length > 0) {
        this.setData({
          show: true,
        });
        wx.showLoading({
          title: this.properties.action === "save" ? "保存中" : "生成中",
          mask: true,
        });
        wx.nextTick(() => {
          this.saveImageByCanvas();
        });
      }
    },
  },

  methods: {
    async saveImageByCanvas() {
      if (!this.properties.width || !this.properties.height) {
        console.log("%c----需要设定海报的宽高----", "color: yellow;");
        return;
      }
      this.setCanvasSize();

      const nodeList = await this.getNode("#saveDomOffsetCanvas");

      this.makeCanvasDisplayBetter(nodeList[0]);

      // 绘制前，先清空一次
      this.clearCanvas();

      for (let index = 0; index < this.properties.options.length; index++) {
        let element = this.properties.options[index];
        // 绘制图片
        if (element.type === "image") {
          await this.drawImageByCreateImage(element);
        }
        // 绘制单行字
        if (element.type === "text") {
          await this.fillSingleTextByCanvas(element);
        }
        // 绘制多行字
        if (element.type === "multilineText") {
          await this.fillMultilineTextByCanvas(element);
        }
      }

      if (this.properties.action === "save") {
        this.saveFileToAlbum();
      }
      if (this.properties.action === "generate") {
        this.justGenerateImageAndReturnPath();
      }
    },

    // ----------------------渲染函数------------------------

    fillMultilineTextByCanvas(item) {
      // eslint-disable-next-line no-unused-vars
      return new Promise((res, rej) => {
        this.data.ctx.font = item.font ? item.font + " Arial" : "22px Arial";
        this.data.ctx.fillStyle = item.fillStyle || "#C2A272";
        if (item.line) {
          this.drawMultilineText(item);
        } else {
          console.log("%c----需要设定多行文字行数----", "color: yellow;");
        }
        res(true);
      });
    },

    fillSingleTextByCanvas(item) {
      // eslint-disable-next-line no-unused-vars
      return new Promise((res, rej) => {
        this.setFontStyle(item);
        this.drawText(item);
        res(true);
      });
    },

    drawImageByCreateImage(item) {
      // eslint-disable-next-line no-unused-vars
      return new Promise((res, rej) => {
        let imgObj = this.data.canvas.createImage();
        imgObj.onload = () => {
          if (imgObj.complete) {
            this.drawImage(imgObj, item);
            res(imgObj);
          }
        };
        imgObj.src = item.url;
      });
    },

    drawImage(imgObj, item) {
      // 如果绘制的图片是屏幕居中，则需要手动赋值dx
      if (item.mode === "screenCenter") {
        let dx = (this.data.canvasPixelWidth - item.dWidth) / 2;
        Object.assign(item, {
          dx: dx,
        });
      }
      if (item.mode === undefined && item.dx === undefined) {
        console.log(
          "%c----不是屏幕居中（screenCenter）情况下，需要设置dx属性----",
          "color: yellow;"
        );
        console.log(`%c---${item.url}`, "color: yellow;");
      }
      if (item.borderRadius) {
        // 如果有边框，需要先绘制圆角图片，再绘制圆角矩形
        this.drawRadiusRectImage(imgObj, item);
        this.drawBorder(item);
      } else {
        this.calcThenDrawImage(imgObj, item);
      }
    },

    // ------------------工具函数-----------------
    setFontStyle(item) {
      this.data.ctx.font = item.font ? item.font + " Arial" : "22px Arial";
      this.data.ctx.fillStyle = item.fillStyle || "#C2A272";
      this.data.ctx.textAlign = item.textAlign || "start";
      this.data.ctx.textBaseline = item.textBaseline || "middle";
    },

    drawMultilineText(item) {
      this.getWrapText(item).forEach((e) => {
        // 多行文字绘制，需要固定为 start和top
        Object.assign(item, {
          textAlign: "start",
          textBaseline: "top",
        });
        this.setFontStyle(item);
        this.drawText(e);
      });
    },

    drawText(item) {
      if (item.letterSpacing > 0) {
        // 如果有letterSpacing字间距，则通过逐字形式来渲染
        let totalWidth = item.dx; // 渲染字符的起始dx位置
        if (!item.dx) {
          console.log(
            "%c----如果没有传入dx字段，则会默认屏幕居中----",
            "color: yellow;"
          );
          console.log(`%c${item.content}-未设置dx的值`, "color: yellow;");
          let strWidth = this.data.ctx.measureText(item.content).width;
          totalWidth =
            (this.data.canvasPixelWidth -
              strWidth -
              item.letterSpacing * (item.content.length - 1)) /
            2;
        }
        // 根据letterSpacing逐字渲染出来
        for (let i = 0; i < item.content.length; i++) {
          this.data.ctx.fillText(item.content[i], totalWidth, item.dy);
          totalWidth +=
            this.data.ctx.measureText(item.content[i]).width +
            item.letterSpacing;
        }
      } else {
        // 如果没有letterSpacing，则直接fillText形式渲染，节省性能
        if (item.mode === "screenCenter") {
          // 文字相对于屏幕居中
          this.data.ctx.textAlign = "center";
          this.data.ctx.fillText(
            item.content,
            this.data.canvasPixelWidth / 2,
            item.dy
          );
        } else {
          this.data.ctx.fillText(item.content, item.dx, item.dy);
        }
      }
    },

    getWrapText(item) {
      let lineHeight = item.lineHeight || 20;
      let letterSpacing = item.letterSpacing || 0;
      let txtList = [];
      let str = "";
      for (let i = 0, len = item.content.length; i < len; i++) {
        str += item.content.charAt(i);
        if (
          this.data.ctx.measureText(str).width +
            letterSpacing * (str.length - 1) >
          item.maxWidth
        ) {
          let textInfo = {
            type: "text",
            font: item.font,
            fillStyle: item.fillStyle,
            content: str.substring(0, str.length - 1),
            dx: item.dx,
            dy: item.dy + lineHeight * txtList.length,
            mode: item.mode || "",
            maxWidth: item.maxWidth,
            letterSpacing: item.letterSpacing,
          };
          txtList.push(textInfo);
          str = "";
          i--;
        }
      }
      txtList.push({
        type: "text",
        font: item.font,
        fillStyle: item.fillStyle,
        content: str,
        dx: item.dx,
        dy: item.dy + lineHeight * txtList.length,
        mode: item.mode || "",
      });
      if (txtList.length >= item.line) {
        let index = item.line - 1;
        let lastTextItem = txtList[index]["content"];
        let penultimateStr = lastTextItem[lastTextItem.length - 2];
        let curEndIndex = -1;
        // 如果倒数第二个字刚好也是标点符号，则直接将其去掉
        if (
          this.patchZhMark(penultimateStr) ||
          this.patchEnMark(penultimateStr)
        ) {
          curEndIndex = -2;
        }
        Object.assign(txtList[index], {
          content: lastTextItem.slice(0, curEndIndex) + "...",
        });
      }
      let finalTxtList = txtList.splice(0, item.line);
      return finalTxtList;
    },

    drawRadiusRectImage(imgObj, item) {
      // 绘制圆角图片原理：
      // 1.先保存当前画面，
      // 2.裁剪出圆角矩形画布，
      // 3.绘制图片，
      // 4.恢复裁剪之前的画面
      this.data.ctx.save(); // 保存
      this.drawRadiusRect(
        item.dx,
        item.dy,
        item.dWidth,
        item.dHeight,
        item.borderRadius
      ); // 画出圆角画布
      this.data.ctx.clip(); // 裁剪
      this.calcThenDrawImage(imgObj, item); // 绘图
      this.data.ctx.restore(); // 恢复裁剪前的画面
    },

    drawBorder(item) {
      this.data.ctx.strokeStyle = item.borderColor || "#E0C069";
      this.drawRadiusRect(
        item.dx,
        item.dy,
        item.dWidth,
        item.dHeight,
        item.borderRadius
      );
      this.data.ctx.stroke();
    },

    calcThenDrawImage(imgObj, item) {
      const { sx, sy, sWidth, sHeight } = this.calcDrawDistance(imgObj, item);
      this.data.ctx.drawImage(
        imgObj,
        sx,
        sy,
        sWidth,
        sHeight,
        item.dx,
        item.dy,
        item.dWidth,
        item.dHeight
      );
    },

    calcDrawDistance(imgObj, item) {
      let sx = 0;
      let sy = 0;
      //  通常情况下，我们传入的图片宽高就是需要绘制到canvas上的宽高
      let sWidth = item.dWidth;
      let sHeight = item.dHeight;

      if (item.objectFit === "aspectFill") {
        // 裁剪模式一般是图片本身大小和需要显示出来的大小不匹配，需要裁剪一部分，
        let imageRatio = imgObj.width / imgObj.height;
        let screenRatio = item.dWidth / item.dHeight;
        if (imageRatio >= screenRatio) {
          sWidth = (item.dWidth * imgObj.height) / item.dHeight;
          sHeight = imgObj.height;
          sx = (imgObj.width - sWidth) / 2;
          sy = 0;
        } else {
          sWidth = imgObj.width;
          sHeight = (item.dHeight * imgObj.width) / item.dWidth;
          sx = 0;
          sy = (imgObj.height - sHeight) / 2;
        }
        return {
          sx,
          sy,
          sWidth,
          sHeight,
        };
      } else {
        sWidth = imgObj.width;
        sHeight = imgObj.height;
        return {
          sx,
          sy,
          sWidth,
          sHeight,
        };
      }
    },

    setCanvasSize() {
      this.setData({
        canvasPixelWidth: this.properties.width,
        canvasPixelHeight: this.properties.height,
      });
    },

    calcCanvasSize(w, h) {
      // 如果canvas上的style内联width/height非常大，那么，真机上绘制图片时，可能会白屏
      // https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html
      // 渲染高度限制：IOS实际像素 < 4096，实际高度需 < 4096/3 = 1356
      // 即：如果canvas的内联样式宽/高度在1350以内，真机可以正常渲染
      // 此处为了兼容性，函数会直接将canvas的内联宽高缩放至屏幕大小
      if (w > this.data.screenWidth || h > this.data.screenHeight) {
        let screenRatio = this.data.screenWidth / this.data.screenHeight;
        let selfRatio = w / h;
        if (screenRatio > selfRatio) {
          w = (w * this.data.screenHeight) / h;
          h = this.data.screenHeight;
        } else {
          h = (h * this.data.screenWidth) / w;
          w = this.data.screenWidth;
        }
      }
      return { w, h };
    },

    getNode(id) {
      return new Promise((res, rej) => {
        const query = wx.createSelectorQuery().in(this);
        query
          .select(id)
          .fields({ node: true, size: true })
          .exec((e) => {
            if (e[0]) {
              res(e);
            } else {
              rej(e);
            }
          });
      });
    },

    makeCanvasDisplayBetter(nodeInfo) {
      const { node: canvas } = nodeInfo;
      const ctx = canvas.getContext("2d");
      // 此处将canvas的尺寸扩大（3倍）,缩放扩大（3倍），
      // 并且在style内联样式中又指定canvas的宽（1倍）和高（1倍），来实现更清晰的canvas显示效果。
      // 原理：生成3倍大小canvas，通过css缩放到1倍宽高的dom中显示。
      // 相当于将900*900的图片，展示到一个300*300大小的dom框中，清晰度会提高。
      // 微信小程序会显示canvas的最大尺寸为：4096*4096，超出会报错
      const dpr = this.calcDPR(this.data.pixelRatio);
      canvas.width = this.data.canvasPixelWidth * dpr;
      canvas.height = this.data.canvasPixelHeight * dpr;
      ctx.scale(dpr, dpr);
      this.setData({
        canvas,
        ctx,
      });
    },

    calcDPR(pixelRatio) {
      let dpr = pixelRatio;
      if (
        this.data.canvasPixelWidth * pixelRatio > 4096 ||
        this.data.canvasPixelHeight * pixelRatio > 4096
      ) {
        const shortDPR = this.calcDPR(pixelRatio - 1);
        return shortDPR;
      } else {
        return dpr;
      }
    },

    saveFileToAlbum() {
      wx.canvasToTempFilePath({
        x: 0,
        y: 0,
        canvas: this.data.canvas,
        success: (res) => {
          wx.saveImageToPhotosAlbum({
            filePath: res.tempFilePath,
            success: () => {
              this.triggerEvent("finish");
              this.setData({
                show: false,
              });
            },
            complete: () => {
              wx.hideLoading();
            },
          });
        },
      });
    },

    justGenerateImageAndReturnPath() {
      wx.canvasToTempFilePath({
        x: 0,
        y: 0,
        canvas: this.data.canvas,
        success: (res) => {
          if (res.tempFilePath) {
            this.triggerEvent("filepath", res.tempFilePath);
            this.setData({
              show: false,
            });
          } else {
            console.log("生图失败");
          }
        },
        complete: () => {
          wx.hideLoading();
        },
      });
    },

    drawRadiusRect(x, y, w, h, r) {
      const br = r;
      let ctx = this.data.ctx;
      ctx.beginPath();
      ctx.moveTo(x + br, y); // 移动到左上角的点
      ctx.lineTo(x + w - br, y); // 画上边的线
      ctx.arcTo(x + w, y, x + w, y + br, br); // 画右上角的弧
      ctx.lineTo(x + w, y + h - br); // 画右边的线
      ctx.arcTo(x + w, y + h, x + w - br, y + h, br); // 画右下角的弧
      ctx.lineTo(x + br, y + h); // 画下边的线
      ctx.arcTo(x, y + h, x, y + h - br, br); // 画左下角的弧
      ctx.lineTo(x, y + br); // 画左边的线
      ctx.arcTo(x, y, x + br, y, br); // 画左上角的弧
      ctx.closePath();
    },

    //判断字符是否是 中文符号
    patchZhMark(temp) {
      var reg =
        /[\u3002|\uff1f|\uff01|\uff0c|\u3001|\uff1b|\uff1a|\u201c|\u201d|\u2018|\u2019|\uff08|\uff09|\u300a|\u300b|\u3008|\u3009|\u3010|\u3011|\u300e|\u300f|\u300c|\u300d|\ufe43|\ufe44|\u3014|\u3015|\u2026|\u2014|\uff5e|\ufe4f|\uffe5]/;
      if (reg.test(temp)) {
        return true;
      } else {
        return false;
      }
    },

    //判断字符是否是 英文半角符号
    patchEnMark(temp) {
      var reg = /[\x21-\x2f\x3a-\x40\x5b-\x60\x7B-\x7F]/;
      if (reg.test(temp)) {
        return true;
      } else {
        return false;
      }
    },

    clearCanvas() {
      this.data.ctx.clearRect(
        0,
        0,
        this.data.canvasPixelWidth,
        this.data.canvasPixelHeight
      );
    },

    // ------------------功能函数-----------------
  },
});

```


```css
.save-dom-canvas-container {
  position: fixed;
  top: -9999px;
  left: -9999px;
  width: 100vw;
  height: 100vh;
}
```

```html
<view class="save-dom-canvas-container" wx:if="{{show}}">
  <canvas
    type="2d"
    id="saveDomOffsetCanvas"
    style="width:{{canvasPixelWidth}}px;height:{{canvasPixelHeight}}px"
  />
</view>
```


### 下拉刷新组件

```html
<scroll-view
  scroll-y
  enable-passive="{{true}}"
  enhanced="{{true}}"
  bounces="{{false}}"
  fast-deceleration="{{true}}"
  refresher-enabled="{{true}}"
  lower-threshold="{{100}}"
  refresher-threshold="{{refresherThresholdHeight}}"
  refresher-default-style="none"
  refresher-triggered="{{triggered}}"
  style="height:{{contentHeight}}"
  bindrefresherrefresh="onDefaultRefresh"
  bindrefresherpulling="onPulling"
  bindrefresherrestore="onRestore"
  bindscrolltolower="onLoadmore"
  bind:touchend="dragend"
>
  <!-- scroll-view 自定义下拉刷新节点需要声明为 slot="refresher" -->
  <view slot="refresher" class="refresh-container">
    <view class="bottom-refresh-container" style="height:{{refresherThresholdHeight}}px">
      <image src="{{refreshLogo}}" mode="aspectFit" class="bottom-refresh-bc-image" />
      <block wx:if="{{refreshstate == 'pulldown'}}">下拉刷新</block>
      <block wx:elif="{{refreshstate == 'loosen'}}">松手刷新</block>
      <block wx:elif="{{refreshstate == 'loading'}}">刷新中...</block>
    </view>
  </view>
  <!-- bounces： ios上该属性需要关闭，否则会导致第二次下拉刷新时，屏幕抖动 -->
  <!-- 在ios中，当view overflow:auto时，view在下拉到顶部或者底部时会有一部分弹性距离，但是当这个view内有setData发生时，view会立即复原，从而导致你在拉到底部时弹性距离刚出现一部分又被setData复原了 ，如果一直拉住不放就会一直重复这个过程，所有在我们看来就是页面在疯狂的抖动了-->
  <slot></slot>
</scroll-view>
```

```css
.refresh-container {
  display: flex;
  flex-flow: column nowrap;
  align-items: center;
  justify-content: flex-end;
  width: 100%;
  height: 100vh;
  background-color: #fff;

  /* background: linear-gradient(
    180deg,
    #ffe7b9 12.78%,
    #fff2d8 22.45%,
    #fffbf2 32.77%,
    #fffbf2 78.45%,
    #fff 87.05%
  ); */
}

.bottom-refresh-container {
  position: relative;
  display: flex;
  flex-flow: column nowrap;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 80px;
  color: #d2ab64;
  font-weight: 500;
  font-size: 15px;
  letter-spacing: 1px;
}

.bottom-refresh-bc-image {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 80%;
  height: 40px;
  transform: translate(-50%, -50%);
  opacity: 0.1;
}

```

```js
const { getStaticUrl } = require("@/utils/assets");

Component({
  options: {},
  properties: {
    contentHeight: {
      type: String,
      value: "500px",
    },
  },
  data: {
    timeout: null,
    triggered: false,
    refreshstate: "pulldown",
    refreshLogo: getStaticUrl("header/full_name_with_bg_short.png"),
    refresherThresholdHeight: 80,
  },
  ready() {},
  methods: {
    debounce(fn, wait) {
      let that = this;
      this.setData({
        timeout: null,
      });
      return function () {
        if (that.data.timeout !== null) {
          clearTimeout(that.data.timeout);
        }
        const timeout = setTimeout(() => {
          fn();
        }, wait);
        that.setData({
          timeout,
        });
      };
    },
    onLoadmore() {
      this.debounce(() => {
        this.triggerEvent("loadmore");
        wx.vibrateShort();
      }, 500)();
    },

    onPulling(evt) {
      let p = Math.min(
        evt.detail.dy / (this.data.refresherThresholdHeight + 20),
        1
      );
      this.p = p ? p : 0;
      if (p >= 0.8) {
        this.setData({
          refreshstate: "loosen",
        });
      } else {
        this.setData({
          refreshstate: "pulldown",
        });
      }
    },
    onDefaultRefresh() {
      wx.vibrateShort();
      this.triggerEvent("refresh");
      this.debounce(() => {
        this.settriggered(false);
      }, 1000)();
    },
    onRestore() {
      console.log("自定义下拉刷新被复位");
    },

    dragend() {
      if (this.p > 0.6 && this.data.refreshstate !== "loading") {
        this.setData({
          refreshstate: "loading",
        });
      } else {
        this.settriggered(false);
      }
    },

    settriggered(flag) {
      return new Promise((resolve) => {
        this.setData(
          {
            triggered: flag,
          },
          () => {
            resolve();
          }
        );
      });
    },
  },
});

```


#### 使用组件

```html
<scroller
  contentHeight="calc(100vh - 194.2308rpx)"
  bind:refresh="onReachTop"
  bind:loadmore="onReachBottom"
>
</scroller>
```
